
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "/about/index.html",
    "title": "",
    "body": ""
    }, {
    "id": 2,
    "url": "/ai/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": ""
    }, {
    "id": 3,
    "url": "/algorithm/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  Leetcode:      "
    }, {
    "id": 4,
    "url": "/all/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  Linux:                                                                                                  add user              :       linux新增带超级权限的普通用户:                                                                               Yan                05 Jun 2020                                                                                                                                    ruby              :       通过RVM安装ruby,可以安装多个版本的ruby,兼容性也更好:                                                                               Yan                05 Jun 2020                                                                                                                                        Ubuntu 20. 04 配置              :       搜狗输入法:                                                                               Yan                16 Jun 2020                                                            Embedded:                                                                                                  增加单总线支持              :       通过GPIO连接控制单总线:                                                                               Yan                17 Jul 2020                                                                                                                                    device-tree-compiler              :       device-tree-compiler 是用于dts和dtb的工具合集:                                                                               Yan                18 Jul 2020                                                                                                                                        Auto Reboot              :       设置reboot_mode变量,在uboot和kernel见传递,实现linux下自动重启,用于老化板子使用:                                                                               Yan                04 Aug 2020                                                                             Algorithm:        Prog-lang:                                                                                                  python调用C接口              :       python主要通过ctype与C语言进行接口对接,这里是常用的对接方法:                                                                               Yan                17 Jun 2020                                                                                                                                    c++上使用opencv              :       opencv支持的图片格式:                                                                               Yan                23 Jul 2020                                                                                                                                    Linux-C下的输入事件分析              :       linux输入子系统协议用类型types和编码codecs来表示输入设备的值并用此来通知用户空间. :                                                                               Yan                19 Nov 2020                                          AI:        Miscellaneous:                                                                                                  VIM              :       VIM编辑器配置:                                                                               Yan                29 May 2020                                                                                                                                    Git              :       Git个人常用的一些配置:                                                                               Yan                30 May 2020                                                                                                                                    ssh              :       ssh是linux远程操作和管理服务的重要工具:                                                                               Yan                30 May 2020                                                                          Message:                                                                                                  打包deb包碰见的编译错误              :       记录打包deb包碰见的bug以及解决方法:                                                                               Yan                30 Jul 2020                                                                                                                                        内存相关信息              :       1. Python快速释放内存:                                                                               Yan                18 Nov 2021                                                "
    }, {
    "id": 5,
    "url": "/embedded/application/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                如何在linux系统上获取扫描枪数据              :       Linux获取扫描枪数据,通过对/dev/input目录下的输节点监测,并读取其中的数据:                                                                               Yan                19 Nov 2020                                                                                                                                Ubuntu下编译mesa包              :       记录如何在ubuntu20. 40上编译适配的mesa包:                                                                               Yan                02 Apr 2021                                                                                                                                压力测试工具stress              :       stress是linux下常用的压力测试工具，这里介绍如何使用stress对板子性能进行测试:                                                                               Yan                18 Nov 2021                                                                                                                                编译并打包OpenCV              :       这篇记录如何在arm环境下编译opencv并打包成deb包。:                                                                               Yan                06 Jan 2022                                       "
    }, {
    "id": 6,
    "url": "/linux/basic-linux/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                add user              :       linux新增带超级权限的普通用户:                                                                               Yan                05 Jun 2020                                                                                                                                压缩解压工具              :       tar/gz/bz:                                                                               Yan                10 Jun 2020                                                                                                                                Linux下格式化存储器              :       这篇记录如何在Linux下格式化如SSD，u盘硬盘之类的存储器:                                                                               Yan                06 Jan 2022                                       "
    }, {
    "id": 7,
    "url": "/embedded/buildroot/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                buildroot如何连接wifi              :       wpa_cli:                                                                               Yan                21 Jul 2020                                                                                                                                打开蓝牙配置工具Bluez              :       Bluez是linux下用于配置蓝牙的一系列工具的合集:                                                                               Yan                21 Nov 2020                                       "
    }, {
    "id": 8,
    "url": "/prog-lang/c++/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                c++上使用opencv              :       opencv支持的图片格式:                                                                               Yan                23 Jul 2020                                       "
    }, {
    "id": 9,
    "url": "/prog-lang/c/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                Linux-C下的输入事件分析              :       linux输入子系统协议用类型types和编码codecs来表示输入设备的值并用此来通知用户空间. :                                                                               Yan                19 Nov 2020                                       "
    }, {
    "id": 10,
    "url": "/categories/index.html",
    "title": "Categories",
    "body": ""
    }, {
    "id": 11,
    "url": "/embedded/combine/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                Auto Reboot              :       设置reboot_mode变量,在uboot和kernel见传递,实现linux下自动重启,用于老化板子使用:                                                                               Yan                04 Aug 2020                                                                                                                                调试命令合集              :        挂载调试文件系统debugfs:                                                                               Yan                28 Oct 2020                                       "
    }, {
    "id": 12,
    "url": "/linux/development/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                ruby              :       通过RVM安装ruby,可以安装多个版本的ruby,兼容性也更好:                                                                               Yan                05 Jun 2020                                                                                                                                Linux下创建python虚拟环境的几种方法              :       这篇主要介绍在Linux下创建python虚拟环境的几种方法。这里的Linux系统使用Ubuntu作为示例。:                                                                               Yan                09 Jul 2021                                       "
    }, {
    "id": 13,
    "url": "/embedded/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  Combine:                                                                                                 Auto Reboot              :       设置reboot_mode变量,在uboot和kernel见传递,实现linux下自动重启,用于老化板子使用:                                                                               Yan                04 Aug 2020                                                                                                                                   调试命令合集              :        挂载调试文件系统debugfs:                                                                               Yan                28 Oct 2020                                          Uboot:                                                                                                 如何设置uboot的Autoboot              :       配置uboot的Autoboot. 使系统在自动启动内核前,可以手动停留在uboot命令行:                                                                               Yan                20 Nov 2020                                          Kernel:                                                                                                 增加单总线支持              :       通过GPIO连接控制单总线:                                                                               Yan                17 Jul 2020                                                                                                                                      Advanced Linux Sound Architecture              :       ALSA(Advanced Linux Sound Architecture)简单使用:                                                                               Yan                29 Aug 2020                                             Buildroot:                                                                                                 buildroot如何连接wifi              :       wpa_cli:                                                                               Yan                21 Jul 2020                                                                                                                                   打开蓝牙配置工具Bluez              :       Bluez是linux下用于配置蓝牙的一系列工具的合集:                                                                               Yan                21 Nov 2020                                          Application:                                                                                                 如何在linux系统上获取扫描枪数据              :       Linux获取扫描枪数据,通过对/dev/input目录下的输节点监测,并读取其中的数据:                                                                               Yan                19 Nov 2020                                                                                                                                   Ubuntu下编译mesa包              :       记录如何在ubuntu20. 40上编译适配的mesa包:                                                                               Yan                02 Apr 2021                                                                                                                                   压力测试工具stress              :       stress是linux下常用的压力测试工具，这里介绍如何使用stress对板子性能进行测试:                                                                               Yan                18 Nov 2021                                             others:                                                                                                 device-tree-compiler              :       device-tree-compiler 是用于dts和dtb的工具合集:                                                                               Yan                18 Jul 2020                                        "
    }, {
    "id": 14,
    "url": "/prog-lang/golang/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:      "
    }, {
    "id": 15,
    "url": "/",
    "title": "",
    "body": ""
    }, {
    "id": 16,
    "url": "/embedded/kernel/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:                                                                                                增加单总线支持              :       通过GPIO连接控制单总线:                                                                               Yan                17 Jul 2020                                                                                                                                sound card 调试              :       HDMI以及CVBS的sound card调试记录:                                                                               Yan                04 Aug 2020                                                                                                                                Advanced Linux Sound Architecture              :       ALSA(Advanced Linux Sound Architecture)简单使用:                                                                               Yan                29 Aug 2020                                                                                                                                内核增加docker配置              :       这篇主要记录如何在ARM64上的内核上配置支持Docker:                                                                               Yan                23 Oct 2021                                       "
    }, {
    "id": 17,
    "url": "/algorithm/leetcode/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:      "
    }, {
    "id": 18,
    "url": "/linux/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  basic-linux:                                                                                                 add user              :       linux新增带超级权限的普通用户:                                                                               Yan                05 Jun 2020                                                                                                                                   压缩解压工具              :       tar/gz/bz:                                                                               Yan                10 Jun 2020                                                                                                                                   Linux下格式化存储器              :       这篇记录如何在Linux下格式化如SSD，u盘硬盘之类的存储器:                                                                               Yan                06 Jan 2022                                          Ubuntu:                                                                                                 Ubuntu 20. 04 配置              :       搜狗输入法:                                                                               Yan                16 Jun 2020                                                                                                                                   deb包管理              :       deb包是DEBIAN系linux操作系统的系统包格式,也是APT源安装的包格式:                                                                               Yan                08 Jul 2020                                                                                                                                   Ubuntu下使用VNC              :       这篇记录如何在Ubuntu20. 04下配置使用VNC。:                                                                               Yan                12 Jul 2021                                             Development:                                                                                                 ruby              :       通过RVM安装ruby,可以安装多个版本的ruby,兼容性也更好:                                                                               Yan                05 Jun 2020                                                                                                                                   Linux下创建python虚拟环境的几种方法              :       这篇主要介绍在Linux下创建python虚拟环境的几种方法。这里的Linux系统使用Ubuntu作为示例。:                                                                               Yan                09 Jul 2021                                          Shell:      "
    }, {
    "id": 19,
    "url": "/prog-lang/make/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 20,
    "url": "/message/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: first-level-classification ,page. first-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 21,
    "url": "/miscellaneous/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: first-level-classification ,page. first-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 22,
    "url": "/embedded/others/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 23,
    "url": "/prog-lang/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  C Program:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[0] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   C++ Program:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[1] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   Shell:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[2] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   Make:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[3] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   Python:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[4] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   Golang:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[5] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %}   Web:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification[6] %}  {% for post in posts reversed %}  {% if post. top-twice == true %}  {% include postbox. html %}  {% endif %}  {% endfor %} "
    }, {
    "id": 24,
    "url": "/prog-lang/python/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 25,
    "url": "/linux/shell/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 26,
    "url": "/prog-lang/shell/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 27,
    "url": "/embedded/uboot/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 28,
    "url": "/linux/ubuntu/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 29,
    "url": "/prog-lang/web/index.html",
    "title": "Time is always silent and it takes time for flowers to bloom . Must be patient .",
    "body": "  All Stories:    {% assign posts=site. posts | where: twice-level-classification ,page. twice-level-classification %}  {% for post in posts reversed %}  {% include postbox. html %}  {% endfor %} "
    }, {
    "id": 30,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 31,
    "url": "/page2/",
    "title": "",
    "body": ""
    }, {
    "id": 32,
    "url": "/page3/",
    "title": "",
    "body": ""
    }, {
    "id": 33,
    "url": "/page4/",
    "title": "",
    "body": ""
    }, {
    "id": 34,
    "url": "/page5/",
    "title": "",
    "body": ""
    }, {
    "id": 35,
    "url": "/page6/",
    "title": "",
    "body": ""
    }, {
    "id": 36,
    "url": "/page7/",
    "title": "",
    "body": ""
    }, {
    "id": 37,
    "url": "/page8/",
    "title": "",
    "body": ""
    }, {
    "id": 38,
    "url": "/page9/",
    "title": "",
    "body": ""
    }, {
    "id": 39,
    "url": "/page10/",
    "title": "",
    "body": ""
    }, {
    "id": 40,
    "url": "/page11/",
    "title": "",
    "body": ""
    }, {
    "id": 41,
    "url": "/page12/",
    "title": "",
    "body": ""
    }, {
    "id": 42,
    "url": "/page13/",
    "title": "",
    "body": ""
    }, {
    "id": 43,
    "url": "/page14/",
    "title": "",
    "body": ""
    }, {
    "id": 44,
    "url": "/page15/",
    "title": "",
    "body": ""
    }, {
    "id": 45,
    "url": "/2022/03/18/v2ray-application.html",
    "title": "搭建V2Ray服务",
    "body": "2022/03/18 - Linux获取应用: 1234$ mkdir ~/v2ray &amp;&amp; cd ~/v2ray$ git clone https://github. com/yan-wyb/v2rayApplication. git$ cd v2rayApplication$ unzip v2ray-linux-64. zip配置客户端: Step1: 配置V2Ray:  打开客户端,选择Preferences  1$ . /Qv2ray-v2. 7. 0-linux-x64. AppImage       选择Kernel Settings,V2Ray核心文件件配置为上一步获取的仓库中的V2Ray核心文件夹Step2: 添加V2Ray节点:  选择import添加节点 将VMESS链接添加到Share Link,点击Import完成添加 点击已添加的节点或者有右击节点连接注意: 手动添加节点信息，不使用VMESS链接的，请点击NEW添加。自此，V2Ray插件已经可以正常运行起来了。 额外协议支持: 点击查看本地插件文件夹，将仓库内的插件添加到对应的文件，重启软件 Windows安装客户端:  点击下载Qv2ray-v2. 7. 0-Windows-Installer. exe 双击安装，全部选择默认选项配置V2Ray:  桌面新建文件夹v2ray, 将v2ray-windows-64. zip解压到桌面的文件夹内。 配置V2Ray核心文件路径，首选项 –&gt; 内核配置: 导入节点。点击导入，将VMESS链接粘贴在分享链接出。 双击默认分组，就能看到刚才配置的节点，连接就能使用。"
    }, {
    "id": 46,
    "url": "/2022/03/09/yocto.html",
    "title": "Amlogic Yocto使用记录",
    "body": "2022/03/09 - 记录VIM4开发Yocto过程中碰见的问题。 1. 查看单包支持的所有命令: 以uboot为例 12345678910111213141516171819202122232425262728yan@yan-wyb:~/yan/git/khadas/amlogic/Yocto-SDK/build$ bitbake u-boot -c listtasksdo_build           Default task for a recipe - depends on all other normal tasks required to 'build' a recipedo_buildclean        Call 'make clean' or equivalent in /home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/u-boot/v2019. 01+git999-r1/u-boot-v2019. 01+git999/do_checkuri         Validates the SRC_URI valuedo_clean           Removes all output files for a targetdo_cleanall         Removes all output files, shared state cache, and downloaded source files for a targetdo_cleansstate        Removes all output files and shared state cache for a targetdo_compile          Compiles the source in the compilation directorydo_configure         Configures the source by enabling and disabling any build-time and configuration options for the software being builtdo_deploy          Writes deployable output files to the deploy directorydo_deploy_source_date_epochdo_devpyshell        Starts an interactive Python shell for development/debuggingdo_devshell         Starts a shell with the environment set up for development/debuggingdo_fetch           Fetches the source codedo_install          Copies files from the compilation directory to a holding areado_listtasks         Lists all defined tasks for a targetdo_package          Analyzes the content of the holding area and splits it into subsets based on available packages and filesdo_package_qa        Runs QA checks on packaged filesdo_package_write_ipk     Creates the actual IPK packages and places them in the Package Feed areado_packagedata        Creates package metadata used by the build system to generate the final packagesdo_patch           Locates patch files and applies them to the source codedo_populate_lic       Writes license information for the recipe that is collected later when the image is constructeddo_populate_sysroot     Copies a subset of files installed by do_install into the sysroot in order to make them available to other recipesdo_prepare_recipe_sysrootdo_unpack          Unpacks the source code into a working directoryNOTE: Tasks Summary: Attempted 1 tasks of which 0 didn't need to be rerun and all succeeded. NOTE: Writing buildhistoryNOTE: Writing buildhistory took: 2 seconds每个layer支持的命令有所差异 2. Python版本不对: 1234567891011121314151617181920212223OpenEmbedded requires 'python' to be python v2 (&gt;= 2. 7. 3), not python v3. Please set up python v2 as your default 'python' interpreter. bash: conf/local. conf: No such file or directory===========================================MACHINE=mesont7-an400OUTPUT_DIR=buildAML_PATCH_PATH=/aml-patches-invalid===========================================Common targets are:amlogic-image-bootstrapamlogic-yoctopackagegroup-amlogic-baserootfspackagegroup-amlogic-fullrootfsrecovery-imagevbmeta-imagevendor-imagegrep: . /. . /. repo/manifest. xml: No such file or directory Manifest Name = Missing file /home/yan/yan/git/khadas/amlogic/Yocto-SDK/. repo/manifests/. conf !!! Please check. Yocto只支持Python2,需要确保使用了Python2的环境，如果使用了conda等虚拟环境请先退出。 3. 内核修改后未clean报错: 12345678910111213141516171819202122232425ERROR: linux-meson-5. 4. 125+git999-r2 do_compile: oe_runmake failedERROR: linux-meson-5. 4. 125+git999-r2 do_compile: Execution of '/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/temp/run. do_compile. 32363' failed with exit code 1ERROR: Logfile of failure stored in: /home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/temp/log. do_compile. 32363Log data follows:| DEBUG: Executing python function externalsrc_compile_prefunc| NOTE: linux-meson: compiling from external source tree /home/yan/yan/git/khadas/amlogic/Yocto-SDK/aml-comp/kernel/aml-5. 4| DEBUG: Python function externalsrc_compile_prefunc finished| DEBUG: Executing shell function do_compile| inside kernel_meson| NOTE: make -j 16 HOSTCC=gcc -isystem/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/include -O2 -pipe -L/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -L/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,--enable-new-dtags             -Wl,-rpath-link,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -Wl,-rpath-link,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,-rpath,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -Wl,-rpath,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,-O1 -Wl,--allow-shlib-undefined -Wl,--dynamic-linker=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/sysroots-uninative/x86_64-linux/lib/ld-linux-x86-64. so. 2 HOSTCPP=gcc -E HOSTCXX=g++ -isystem/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/include -O2 -pipe -L/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -L/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,--enable-new-dtags             -Wl,-rpath-link,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -Wl,-rpath-link,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,-rpath,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/usr/lib             -Wl,-rpath,/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native/lib             -Wl,-O1 -Wl,--allow-shlib-undefined -Wl,--dynamic-linker=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/sysroots-uninative/x86_64-linux/lib/ld-linux-x86-64. so. 2 Image. gz CC=aarch64-poky-linux-gcc  -fuse-ld=bfd -fdebug-prefix-map=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2=/usr/src/debug/linux-meson/5. 4. 125+git999-r2           -fdebug-prefix-map=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot=           -fdebug-prefix-map=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot-native=           -fdebug-prefix-map=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work-shared/mesont7-an400/kernel-source=/usr/src/kernel --sysroot=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot --sysroot=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot LD=aarch64-poky-linux-ld. bfd  --sysroot=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot --sysroot=/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/recipe-sysroot| ***| *** The source tree is not clean, please run 'make mrproper'| *** in /home/yan/yan/git/khadas/amlogic/Yocto-SDK/aml-comp/kernel/aml-5. 4| ***| make[2]: *** [/home/yan/yan/git/khadas/amlogic/Yocto-SDK/aml-comp/kernel/aml-5. 4/Makefile:562: outputmakefile] Error 1| make[1]: *** [/home/yan/yan/git/khadas/amlogic/Yocto-SDK/aml-comp/kernel/aml-5. 4/Makefile:736: include/config/auto. conf. cmd] Error 2| make[1]: *** [include/config/auto. conf. cmd] Deleting file 'include/config/tristate. conf'| make: *** [/home/yan/yan/git/khadas/amlogic/Yocto-SDK/aml-comp/kernel/aml-5. 4/Makefile:179: sub-make] Error 2| ERROR: oe_runmake failed| WARNING: exit code 1 from a shell command. | ERROR: Execution of '/home/yan/yan/git/khadas/amlogic/Yocto-SDK/build/tmp/work/mesont7_an400-poky-linux/linux-meson/5. 4. 125+git999-r2/temp/run. do_compile. 32363' failed with exit code 1ERROR: Task (/home/yan/yan/git/khadas/amlogic/Yocto-SDK/meta-meson/recipes-kernel/linux/linux-meson_5. 4. bb:do_compile) failed with exit code '1'NOTE: Tasks Summary: Attempted 608 tasks of which 607 didn't need to be rerun and 1 failed. NOTE: Writing buildhistoryNOTE: Writing buildhistory took: 1 seconds其中明显提示了The source tree is not clean, please run 'make mrproper' 清理内核 1$ make distclean再次编译通过 4. Uboot make saveconfig以后未找到defconfig: Amlogic U-Boot代码的编译都会在build目录下进行，因此make savedefconfig以后，在build目录可以找到相应的defcongfig. 5. 内核以及U-Boot配置文件: kernel: meta-meson/recipes-kernel/linux/linux-meson_5. 4. bb U-Boot: meta-meson/recipes-bsp/u-boot/u-boot_2019. 01. bb "
    }, {
    "id": 47,
    "url": "/2022/01/08/google-analytics.html",
    "title": "如何添加google analytics",
    "body": "2022/01/08 - 这里记录如何添加google analytics到网站 1. 申请google analytics账号登录google analytics网站，并注册账号 2. 生成数据流接口 点击设置，找到Account Settings, 选择Data Streams.  选择Add Stream,  输入网站的地址和名称 3. 添加到网站在生成的Stream下面，有一个添加到网站的代码 将其添加到网站的head中即可。以jekyll为例，  在_includes目录下新增google-analytics. html123456789&lt;!-- Global site tag (gtag. js) - Google Analytics --&gt;&lt;script async src= https://www. googletagmanager. com/gtag/js?id=G-D6LYD0GPXC &gt;&lt;/script&gt;&lt;script&gt; window. dataLayer = window. dataLayer || []; function gtag(){dataLayer. push(arguments);} gtag('js', new Date()); gtag('config', 'G-D6LYD0GPXC');&lt;/script&gt; include到_include/head. html中123{% include google-analytics. html %}"
    }, {
    "id": 48,
    "url": "/2022/01/06/kms.html",
    "title": "kms",
    "body": "2022/01/06 - 12345678910111213141516171819kms. 03k. orgkms. chinancce. comkms. lotro. cccy2617. jios. orgkms. shuax. comkms. luody. infokms. cangshui. netzh. us. tokms. library. hkxykz. f3322. orgkms. binye. xyzkms. tttal. comkms. v0v. bidkms. moeclub. orgamrice. topkms. digiboy. irkms. lolico. moekms8. MSGuides. comkms9. MSGuides. com"
    }, {
    "id": 49,
    "url": "/2022/01/06/format-storage.html",
    "title": "Linux下格式化存储器",
    "body": "2022/01/06 - 这篇记录如何在Linux下格式化如SSD，u盘硬盘之类的存储器 确认节点   u盘以及硬盘的节点一般为/dev/sdx     SSD在linux下的节点一般为/dev/nvmex     SD卡在linux下的节点一般为/dev/mmcblkx  设置分区这里以u盘为例。  使用fdisk命令打开设备节点1$ sudo fdisk /dev/sdx   输入 d，删除原有分区，知道显示没有分区为止。     输入p,设置主分区，随后输入g设置，设置为GPT格式。     输入n,设置分区，默认即可，如果你需要格式成多个分区，可以设置分区大小，并再次重复输入n。     输入w，保存退出。  设置分区格式这里依然以U盘为例。 设置完分区以后，数据分区为/dev/sdx1。(SSD以及SSD卡一般后缀是p1)。 使用mkfs命令格式化。 1$ sudo mkfs. ext4 /dev/sdx1这里采用ext4格式，如果使用其他格式可以修改命令。如ntfs为mkfs. ntfs。 挂载依然以u盘为例。 1$ sudo mount /dev/sdx1 /path/to/your/directory"
    }, {
    "id": 50,
    "url": "/2022/01/06/build-and-package-opencv.html",
    "title": "编译并打包OpenCV",
    "body": "2022/01/06 - 这篇记录如何在arm环境下编译opencv并打包成deb包。 获取源码 Clone源码1yan@yan-wyb:~$ git clone https://github. com/opencv/opencv. git 切换到需要的tag这里以4. 5为例， 12yan@yan-wyb:~$ cd opencv/yan@yan-wyb:~/opencv$ git checckout -b 4. 5. 0可以使用git tag命令查看所有可用的tag 编译 opencv编译是使用cmake命令。没有的请先安装cmake，以ubuntu为例1yan@yan-wyb:~$ sudo apt install cmake 创建编译目录12yan@yan-wyb:~$ cd opencvyan@yan-wyb:~/opencv$ mkdir build 使用cmake编译这里编译使用一些常见选项，并安装到当前目录 1234567891011121314yan@yan-wyb:~/opencv$ cd build/yan@yan-wyb:~/opencv/build$ cmake -D CMAKE_BUILD_TYPE=RELEASE \   -D CMAKE_INSTALL_PREFIX=. /install \   -D BUILD_TESTS=OFF \   -D BUILD_EXAMPLES=OFF \   -D INSTALL_PYTHON_EXAMPLES=OFF \   -D BUILD_opencv_gapi=OFF \   -D BUILD_opencv_python2=OFF \   -D BUILD_opencv_python3=ON \   -D PYTHON3_INCLUDE_DIR=/usr/include/python3. 8 \   -D PYTHON3_EXECUTABLE=/usr/bin/python3. 8 \   -D PYTHON3_LIBRARY=/usr/lib/aarch64-linux-gnu/libpython3. 8. so. 1. 0 \   -D PYTHON3_NUMPY_INCLUDE_DIRS=/usr/lib/python3. 8/dist-packages/numpy/core/include/yan@yan-wyb:~/opencv/build$ make等待编译完成，编译完成以后安装到指定的目录，即当前目录下 1yan@yan-wyb:~/opencv/build$ make install如要安装到其他目录可在上一步中指定安装位置-D CMAKE_INSTALL_PREFIX= 打包 创建打包脚本123yan@yan-wyb:~/opencv/build$ cd installyan@yan-wyb:~/opencv/build/install$ mkdir DEBIANyan@yan-wyb:~/opencv/build/install$ vim DEBIAN/control内容如下 12345678Package: opencvVersion: 4. 5. 0Section: kernelArchitecture: arm64Maintainer: Yan &lt;yan-wyb@foxmail. com&gt;Installed-Size: 1Priority: optionalDescription: OpenCV libraries.  打包12yan@yan-wyb:~$ cd opencv/build/yan@yan-wyb:~$ dpkg-deb -b install . /opencv-4. 5. 0. deb"
    }, {
    "id": 51,
    "url": "/2022/01/03/swapfile.html",
    "title": "Ubuntu增加swap空间",
    "body": "2022/01/03 - 记录如何在Ubuntu下手动增加swap空间  创建一个swapfile1yan@yan-wyb:~$ sudo dd if=/dev/zero of=/swapfile bs=1M count=4096 修改权限1yan@yan-wyb:~$ sudo chmod 600 /swapfile 修改文件类型为swap123yan@yan-wyb:~$ sudo mkswap /swapfileSetting up swapspace version 1, size = 4 GiB (4294963200 bytes)no label, UUID=463c559f-b5db-471a-a825-2cd17ee39adb如果你需要开机就自动挂在这个swap，这里的UUID可以记下，再从/etc/fstab里面配置为开机自动加载  启动swapfile1yan@yan-wyb:~$ sudo swapon /swapfilePs: 查看已经加载的swap空间 1yan@yan-wyb:~$ cat /proc/swaps"
    }, {
    "id": 52,
    "url": "/2021/11/18/memory.html",
    "title": "内存相关信息",
    "body": "2021/11/18 - 1. Python快速释放内存: python在del对象后，并不会立刻释放对象占有的内存，当需要快速释放内存时，需要使用python gc包 123import gcgc. collect()"
    }, {
    "id": 53,
    "url": "/2021/11/18/stress-tool.html",
    "title": "压力测试工具stress",
    "body": "2021/11/18 - stress是linux下常用的压力测试工具，这里介绍如何使用stress对板子性能进行测试 安装: 这里以ubuntu为例 1$ sudo apt install stress测试: 直接运行stress,能看到stress的命令参数说明 12345678910111213141516171819202122232425$ stress`stress' imposes certain types of compute stress on your systemUsage: stress [OPTION [ARG]] . . . -?, --help     show this help statement   --version   show version statement -v, --verbose   be verbose -q, --quiet    be quiet -n, --dry-run   show what would have been done -t, --timeout N  timeout after N seconds   --backoff N  wait factor of N microseconds before work starts -c, --cpu N    spawn N workers spinning on sqrt() -i, --io N     spawn N workers spinning on sync() -m, --vm N     spawn N workers spinning on malloc()/free()   --vm-bytes B  malloc B bytes per vm worker (default is 256MB)   --vm-stride B touch a byte every B bytes (default is 4096)   --vm-hang N  sleep N secs before free (default none, 0 is inf)   --vm-keep   redirty memory instead of freeing and reallocating -d, --hdd N    spawn N workers spinning on write()/unlink()   --hdd-bytes B write B bytes per hdd worker (default is 1GB)Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10sNote: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size).  CPU测试1$ stress --cpu N 内存测试1$ stress --vm N --vm-bytes 300M--vm-bytes指定单个进程占的内存  磁盘测试1$ stress --io N --hdd N --hdd-bytes 512M--io 产生N个进程反复调用sync，--hdd产生N个进程写入固定大小临时文件再删除，--hdd-bytes指定文件大小 "
    }, {
    "id": 54,
    "url": "/2021/10/23/docker-configuration.html",
    "title": "内核增加docker配置",
    "body": "2021/10/23 - 这篇主要记录如何在ARM64上的内核上配置支持Docker 使用docker验证脚本验证所需配置 Github Wiki地址： https://github. com/umiddelb/armhf/wiki/Installing,-running,-using-docker-on-armhf-%28ARMv7%29-devices https://github. com/yan-wyb/source/blob/master/shell/docker/check-config. sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105$ curl -L https://raw. githubusercontent. com/docker/docker/master/contrib/check-config. sh | /bin/bash /dev/stdin % Total  % Received % Xferd Average Speed  Time  Time   Time Current                 Dload Upload  Total  Spent  Left Speed100 11991 100 11991  0   0 13382   0 --:--:-- --:--:-- --:--:-- 13382info: reading kernel config from /proc/config. gz . . . Generally Necessary:- cgroup hierarchy: properly mounted [/sys/fs/cgroup]- CONFIG_NAMESPACES: enabled- CONFIG_NET_NS: enabled- CONFIG_PID_NS: enabled- CONFIG_IPC_NS: enabled- CONFIG_UTS_NS: enabled- CONFIG_CGROUPS: enabled- CONFIG_CGROUP_CPUACCT: enabled- CONFIG_CGROUP_DEVICE: enabled- CONFIG_CGROUP_FREEZER: enabled- CONFIG_CGROUP_SCHED: enabled- CONFIG_CPUSETS: enabled- CONFIG_MEMCG: enabled- CONFIG_KEYS: enabled- CONFIG_VETH: enabled- CONFIG_BRIDGE: enabled- CONFIG_BRIDGE_NETFILTER: enabled- CONFIG_IP_NF_FILTER: enabled- CONFIG_IP_NF_TARGET_MASQUERADE: enabled- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled- CONFIG_NETFILTER_XT_MATCH_IPVS: enabled- CONFIG_NETFILTER_XT_MARK: enabled- CONFIG_IP_NF_NAT: enabled- CONFIG_NF_NAT: enabled- CONFIG_POSIX_MQUEUE: enabled- CONFIG_CGROUP_BPF: enabledOptional Features:- CONFIG_USER_NS: enabled- CONFIG_SECCOMP: enabled- CONFIG_SECCOMP_FILTER: enabled- CONFIG_CGROUP_PIDS: enabled- CONFIG_MEMCG_SWAP: enabled- CONFIG_MEMCG_SWAP_ENABLED: enabled  (cgroup swap accounting is currently enabled)- CONFIG_BLK_CGROUP: enabled- CONFIG_BLK_DEV_THROTTLING: enabled- CONFIG_CGROUP_PERF: enabled- CONFIG_CGROUP_HUGETLB: missing- CONFIG_NET_CLS_CGROUP: enabled- CONFIG_CGROUP_NET_PRIO: enabled- CONFIG_CFS_BANDWIDTH: enabled- CONFIG_FAIR_GROUP_SCHED: enabled- CONFIG_RT_GROUP_SCHED: enabled- CONFIG_IP_NF_TARGET_REDIRECT: enabled- CONFIG_IP_VS: enabled- CONFIG_IP_VS_NFCT: enabled- CONFIG_IP_VS_PROTO_TCP: enabled- CONFIG_IP_VS_PROTO_UDP: enabled- CONFIG_IP_VS_RR: enabled- CONFIG_SECURITY_SELINUX: enabled- CONFIG_SECURITY_APPARMOR: enabled- CONFIG_EXT4_FS: enabled- CONFIG_EXT4_FS_POSIX_ACL: enabled- CONFIG_EXT4_FS_SECURITY: enabled- Network Drivers: -  overlay :  - CONFIG_VXLAN: enabled  - CONFIG_BRIDGE_VLAN_FILTERING: enabled   Optional (for encrypted networks):   - CONFIG_CRYPTO: enabled   - CONFIG_CRYPTO_AEAD: enabled   - CONFIG_CRYPTO_GCM: enabled   - CONFIG_CRYPTO_SEQIV: enabled   - CONFIG_CRYPTO_GHASH: enabled   - CONFIG_XFRM: enabled   - CONFIG_XFRM_USER: enabled   - CONFIG_XFRM_ALGO: enabled   - CONFIG_INET_ESP: enabled -  ipvlan :  - CONFIG_IPVLAN: enabled -  macvlan :  - CONFIG_MACVLAN: enabled  - CONFIG_DUMMY: enabled -  ftp,tftp client in container :  - CONFIG_NF_NAT_FTP: enabled  - CONFIG_NF_CONNTRACK_FTP: enabled  - CONFIG_NF_NAT_TFTP: enabled  - CONFIG_NF_CONNTRACK_TFTP: enabled- Storage Drivers: -  aufs :  - CONFIG_AUFS_FS: missing -  btrfs :  - CONFIG_BTRFS_FS: enabled (as module)  - CONFIG_BTRFS_FS_POSIX_ACL: enabled -  devicemapper :  - CONFIG_BLK_DEV_DM: enabled  - CONFIG_DM_THIN_PROVISIONING: enabled -  overlay :  - CONFIG_OVERLAY_FS: enabled (as module) -  zfs :  - /dev/zfs: missing  - zfs command: missing  - zpool command: missingLimits:- /proc/sys/kernel/keys/root_maxkeys: 1000000缺了哪些配置就在内核里面打开。 "
    }, {
    "id": 55,
    "url": "/2021/07/12/github-actions-jekyll.html",
    "title": "Github Actions自动部署jekyll",
    "body": "2021/07/12 - 这篇主要记录如何使用GIthub Actions部署jekyll Repositories设置 首先要在github上把项目设置成public,travis只对开源项目免费，然后将项目clone到本地note : 这里一定要使用ssh的方式clone下来,不能使用https. 12$ cd ${workspace}$ git clone git@github. com:${user}/{your-blog}. git 之后需要新建gh-pages分支,同时推送到远端12$ git branch gh-pages$ git push origin pg-pages 打开github pages打开仓库的setting 在列表中找到github pages,设置成gh-pages分支 Token设置 打开github的setting --&gt; Development Settings.  点击左边最底下的Personal access token,在右上角就会看到Generate new token.  为即将生成的新token设置note，相当于标识，或者别名  设置token的权限  记下token的值，这个值只有第一次生成时会显示，之后就不会再显示了，因此生成时一定要复制下来  将token添加到secrets 部署脚本设置只要在仓库目录下新建. github/workflows文件夹，推送到github以后就会自动触发部署。  新建. github/workflows 文件夹1$ mkdir -p . github/workflows 新建脚本1$ vim . github/workflows/avalon. yaml内容如下， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849name: Publish to my blogon: [push]jobs: build:  runs-on: ubuntu-latest  steps:  - uses: actions/checkout@v2   with:    persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token  - name: Setup Ruby   uses: ruby/setup-ruby@v1  - name: Ruby gem cache   uses: actions/cache@v1   with:    path: vendor/bundle    key: ${{ runner. os }}-gems-${{ hashFiles('**/Gemfile. lock') }}    restore-keys: |     ${{ runner. os }}-gems-  - name: Install gems   run: |    bundle config path vendor/bundle    bundle install --jobs 4 --retry 3  - name: Build Jekyll site   run: JEKYLL_ENV=production bundle exec jekyll build  - name: Commit files   run: |    cd . /_site    git init    git config --local user. name  Your name     git config --local user. email  Your email     git add .     git commit -m  jekyll build at $(date)   - name: Push changes   uses: ad-m/github-push-action@master   with:    directory: . /_site    repository: {{ github user }}/{{ repository name }}    branch: gh-pages    github_token: ${{ secrets. ACCESS_TOKEN }}    force: true其中， 1231. `git config`  要配置成你的git用户2. `repository`  要配置成你的源码仓库3. `ACCESS_TOKEN` 是Token设置中你生成的token 新建ruby版本文件1echo 2. 5. 1 &gt; . ruby-version Push并自动部署代码push到github以后就会触发自动部署， 在Actions就可以看到你的自动部署脚本是否成功运行。 域名重定向 新建CNAME文件并添加自己的域名1echo example. com &gt; CNAME 设置DNS解析这里以阿里云的域名为例， 如上图设置两条dns解析,第二条的解析记录填写你的github. io地址。  打开https在github pages处勾选 "
    }, {
    "id": 56,
    "url": "/2021/07/12/vnc-server.html",
    "title": "Ubuntu下使用VNC",
    "body": "2021/07/12 - 这篇记录如何在Ubuntu20. 04下配置使用VNC。 安装 安装依赖1$ sudo apt-get install gnome-session-flashback 安装VNC Server1$ sudo apt-get install tigervnc-standalone-server配置 关闭防火墙12$ sudo ufw disableFirewall stopped and disabled on system startup关闭以后可以通过status命令查看 12$ sudo ufw statusStatus: inactive 设置密码1234$ vncpasswd Password:Verify:Would you like to enter a view-only password (y/n)? n这个密码是远程连接时需要输入的密码  设置配置文件1$ vim ~/. vnc/xstartup配置内容如下 123456789101112#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSexport XKL_XMODMAP_DISABLE=1export XDG_CURRENT_DESKTOP= GNOME-Flashback:GNOME export XDG_MENU_PREFIX= gnome-flashback- [ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/. Xresources ] &amp;&amp; xrdb $HOME/. Xresourcesxsetroot -solid greyvncconfig -iconic &amp;gnome-session --session=gnome-flashback-metacity --disable-acceleration-check &amp; 添加执行权限1$ sudo chmod +x ~/. vnc/xstartup使用 启动服务端123456789$ vncserver -localhost noCleaning stale pidfile '/home/khadas/. vnc/localhost:1. pid'!New 'localhost:1 (khadas)' desktop at :1 on machine localhostStarting applications specified in /home/khadas/. vnc/xstartupLog file is /home/khadas/. vnc/localhost:1. logUse xtigervncviewer -SecurityTypes VncAuth -passwd /home/khadas/. vnc/passwd :1 to connect to the VNC server.  查看端口根据第一步提供的信息/home/khadas/. vnc/localhost:1. log 1234567$ cat /home/khadas/. vnc/localhost:1. logMon Jul 12 07:39:39 2021 vncext:   VNC extension running! vncext:   Listening for VNC connections on local interface(s), port 5901 vncext:   created VNC server for screen 0 ComparingUpdateTracker: 0 pixels in / 0 pixels out ComparingUpdateTracker: (1:nan ratio) 客户端连接vnc view下载地址，选择自己对应的平台 客户端连接格式 1ip:part #示例192. 168. 1. 172:5091输入密码即可控制远程桌面 "
    }, {
    "id": 57,
    "url": "/2021/07/09/python-virtual-environment.html",
    "title": "Linux下创建python虚拟环境的几种方法",
    "body": "2021/07/09 - 这篇主要介绍在Linux下创建python虚拟环境的几种方法。这里的Linux系统使用Ubuntu作为示例。 CondaConda是一个python包管理工具，可以通过安装anaconda或者miniconda安装conda虚拟环境。 这里以miniconda为例(anaconda和miniconda的区别在于预安装的python包的数量不同)， 安装conda: 12$ wget https://repo. anaconda. com/miniconda/Miniconda3-latest-Linux-x86_64. sh$ bash Miniconda3-latest-Linux-x86_64. sh输入yes同意协议，然后一直回车，就会默认安装到home目录下，miniconda会预安装常用的python数据处理包。 使用conda创建虚拟环境: 激活conda环境: 安装完conda以后，需要先激活conda环境， 12yan@yan:~$ bash(base) yan@yan:~$ 看到(base)前缀就是激活conda环境成功了 创建虚拟环境: conda在创建虚拟环境时可以指定python版本， 1(base) yan@yan:~$ conda create --name yan-wyb python=3. 8 pip这里指定python版本为3. 8，同时包括pip包 激活虚拟环境与退出虚拟环境: 激活创建的虚拟环境 12(base) yan@yan:~$ conda activate yan-wyb(yan-wyb) yan@yan:~$退出虚拟环境 12(yan-wyb) yan@yan:~$ conda deactivate(base) yan@yan:~$Conda与其他方法相比的有点在于，可以指定python版本，同时预装了python基础的数据处理包和常用包。 缺点在于预装包会导致虚拟环境占空间较大，不需要可以使用下面其他方法 pipenvpipenv是Python官方推荐的包管理工具。 安装: 1$ pip install pipenv如果没有安装pip，可以使用下面的命令 1$ sudo apt insall python3-pip创建虚拟环境: 123$ cd ${workspace}$ pipenv install$ pipenv install requests如果不存在pipfile,会生成一个pipfile，创建以后安装新库，会自动更新pipfile. 激活: 12$ pipenv shell$ python --versionvenv安装: 1$ sudo apt install python3-venv创建虚拟环境: 1$ python3 -m venv --system-site-packages . /venv激活环境: 1$ source . /venv/bin/activate退出环境: 1$ deactivateissuesIf there are doubts or errors, please submit an issue –&gt; Issues "
    }, {
    "id": 58,
    "url": "/2021/04/02/build-mesa-package.html",
    "title": "Ubuntu下编译mesa包",
    "body": "2021/04/02 - 记录如何在ubuntu20. 40上编译适配的mesa包 源码mesa源码: mesa源码位于官方自构建的源码网站上, 12$ mkdir ${workspace}$ git clone https://gitlab. freedesktop. org/mesa/mesa直接使用最新的代码,或者选择一个合适的tag,例如使用21. 0. 1 123$ cd ${workspace}/mesa$ git chechout 21. 0. 1$ git checkout -b 21. 0. 1##　DEBIAN编译规则  打开source list的配置1$ vim /etc/apt/sources. list将配置里面的deb-src全部打开 1234#deb-src http://ports. ubuntu. com/ focal main restricted universe multiverse --&gt; deb-src http://ports. ubuntu. com/ focal main restricted universe multiverse#deb-src http://ports. ubuntu. com/ focal-security main restricted universe multiverse --&gt; deb-src http://ports. ubuntu. com/ focal-security main restricted universe multiverse#deb-src http://ports. ubuntu. com/ focal-updates main restricted universe multiverse --&gt; deb-src http://ports. ubuntu. com/ focal-updates main restricted universe multiverse#deb-src http://ports. ubuntu. com/ focal-backports main restricted universe multiverse --&gt; deb-src http://ports. ubuntu. com/ focal-backports main restricted universe multiverse 更新1$ sudo apt update 获取DEBIAN规则12$ cd ${workspace}$ apt source mesa获取的源码里面,有一个debian文件夹,就是需要的编译规则,复制到mesa源码包中 1$ cp -ravx ${workspace}/mesa-20. 2. 6/debian ${workspace}/mesa编译准备 安装编译依赖选项1$ sudo apt-get install devscripts build-essential lintian 安装编译依赖库1$ sudo apt install libxcb-shm0-dev 准备编译环境12$ cd ${workspace}/mesa$ sudo apt build-dep mesa这一步会生成用于编译mesa包的环境配置 编译 清理缓存的编译1$ debuild -i -us -uc -b 不清除缓存的编译1$ debuild -i -us -uc -b -nc编译报错,一般都是DEBIAN规则不使用新版本的源码,修改以后, 需要使用清理缓存的编译 Picturs link "
    }, {
    "id": 59,
    "url": "/2020/11/25/change-source-collection.html",
    "title": "换源方法合集",
    "body": "2020/11/25 - npm 临时换源1--registry https://registry. npm. taobao. org 修改源配置1npm config set registry https://registry. npm. taobao. orgnvm1export NVM_NODEJS_ORG_MIRROR=https://npm. taobao. org/mirrors/noderuby ruby1$ gem sources --add https://gems. ruby-china. com/ --remove https://rubygems. org/ bundler1$ bundle config mirror. https://rubygems. org https://gems. ruby-china. comrvm1echo  ruby_url=https://cache. ruby-china. com/pub/ruby  &gt; /usr/local/rvm/user/dbpython-pip 临时换源1-i https://pypi. tuna. tsinghua. edu. cn/simple 修改源配置1pip config set global. index-url https://pypi. tuna. tsinghua. edu. cn/simpleissues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 60,
    "url": "/2020/11/21/open-buletooth-config-tool-bluez.html",
    "title": "打开蓝牙配置工具Bluez",
    "body": "2020/11/21 - Bluez是linux下用于配置蓝牙的一系列工具的合集 配置步骤 打开buildroot配置界面123$ cd {path/to}/buildroot$ make ARCH=arm64 xxx_defconfig$ make ARCH=arm64 menuconfig 选择Target packagesPicturs  选择Networking applicationsPicturs  选择bluez-utils 5. xPicturs  保存配置12$ make ARCH=arm64 savedefconfig$ mv defconfig configs/xxx_defconfigissues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 61,
    "url": "/2020/11/20/autoboot-setting.html",
    "title": "如何设置uboot的Autoboot",
    "body": "2020/11/20 - 配置uboot的Autoboot. 使系统在自动启动内核前,可以手动停留在uboot命令行 mainline ubootClone最新的主线uboot到本地 12$ cd {workspace}$ git clone https://github. com/u-boot/u-boot. git打开配置界面 从/configs目录下选择你需要的配置. 123456$ cd {workspace}/u-boot$ make ARCH=arm xxx_defconfig## configuration written to . config# 启动配置界面12$ cd {workspace}/u-boot$ make ARCH=arm menuconfig看到启动了配置的UI,就是启动成功了 配置过程 选择 Command line interface 选项  选择 Autoboot options 选项  这里可以配置几个选项    Stop autobooting via specific input key / string : 在启动时,可以通过键盘停下Autoboot     (Autoboot in %d seconds\n) Autoboot stop prompt : 可以输入打印的信息格式     Delay autobooting via specific input key / string: Autoboot的倒计时时长     Stop autobooting via specific input key / string : 通过特定的按键停下,比如空格或者回车,此时其他按键失效  保存配置   选择Save按钮保存你的配置到. config     保存成defconfig  12$ cd {workspace}/u-boot$ make ARCH=arm savedefconfig 将生成的defconfig替换原本的defconfig12$ cd {workspace}/u-boot$ mv defconfig confgis/xxx_defconfigissues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 62,
    "url": "/2020/11/19/input-event.html",
    "title": "Linux-C下的输入事件分析",
    "body": "2020/11/19 - linux输入子系统协议用类型types和编码codecs来表示输入设备的值并用此来通知用户空间. 结构体input_eventinput_event是其中最重要的结构体,该结构体记录了输入事件的所有信息. 定义在文件linux/input. h中 1234567struct input_event{	struct timeval time;	__u16 type;	__u16 code;	__s32 value;}; time 表示事件发生的时间 type 表示事件的类型 code 表示事件的编码 value 表示事件的参数值evnet type定义了输入事件的类型. 例如常见的EV_KEY,按键输入  EV_SYN    : 事件间的分割标志。事件可能按时间或空间进行分割 EV_KEY    : 描述键盘，按键或者类似键盘设备的状态变化 EV_REL    : 描述相对坐标轴上数值的变化 EV_ABS    : 描述相对坐标轴上数值的变化 EV_MSC    : 当不能匹配现有的类型时，使用该类型进行描述 EV_SW    : 描述具备两种状态的输入开关 EV_LED    : 控制设备上的LED灯的开和关 EV_SND    : 用来给设备输出提示声音 EV_REP    : 用于可以自动重复的设备(autorepeating)10. EV_FF    : 给输入设备发送强制回馈命令11. EV_PWR    : 特别用于电源开关的输入12. EV_FF_STATUS : 接收设备的强制反馈状态。所有的event type都定义在include/uapi/linux/input-event-codes. h event code对Event tpye定义的类型进行更详细的定义. 以键盘为例, 当type=EV_KEY时, code=KEY_A`代表了键盘上的A发生了输入事件. 所有event type的详细定义都在include/uapi/linux/input-event-codes. h valuevalue就是事件发生时所带的的参数值. 以键盘为例  value=0表示按键按下 value=1表示按键松开 value=2表示按键自动重复issues如果有疑惑或错误,请提issues –&gt; IssuesIf there are doubts or errors, please submit an issue –&gt; Issues "
    }, {
    "id": 63,
    "url": "/2020/11/19/how-to-get-scanner-data.html",
    "title": "如何在linux系统上获取扫描枪数据",
    "body": "2020/11/19 - Linux获取扫描枪数据,通过对/dev/input目录下的输节点监测,并读取其中的数据 原理分析扫描枪的原理与键盘输入的原理相同,都属于输入设备. 将扫描当成普通的输入事件处理即可,从/dev/input/eventX节点获取扫描的所有数据输入. 通过输入事件的type,value可以筛选出不同的事件,相应的data就是我们需要的扫描枪的输入的值 代码处理获取节点的名字: 在制定输入设备的时候,通常输入通过打印输入设备的名字,确认是否监测对了正确的节点. 1ioctl (fd, EVIOCGNAME (sizeof (name)), name);通过ioctl函数组的EVIOCGNAME获取事件节点的名称,并打印出来,确认节点的正确性 1printf ( Reading From : %s (%s)\n , device, name);获取扫描枪的数据: 当你通过扫描枪扫描了一个条形码或者二维码时,数据就会通过输入事件的形式输入. 1read(fd,&amp;buff,sizeof(struct input_event))关于input_event. 事件结构体的定义和使用,可以参考Linux-C下的输入事件分析 处理获取的数据:  按键的输入有按下和松开两个value. 而扫描枪是类似键盘输入的形式,所以也有value=0和value=1,选择其中一个即可 当数据的类型为1,也就是EV_KEY. 数据才是我们需要的扫描枪的数据123if (buff. value == 1 &amp;&amp; buff. type == 1 ){  printf( i:%d,type:%d code:%d value:%d\n ,i,buff. type,buff. code,buff. value);}示例这里以扫描枪扫描MAC地址为例,扫描以后将数据存储到文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 if (argv[1] == NULL){   printf( Please specify (on the command line) the path to the dev event interface devicen );   exit (0); } if ((getuid ()) != 0)   printf ( You are not root! This may not work. . . n ); if (argc &gt; 1)   device = argv[1]; if ((fd = open (device, O_RDONLY)) == -1)   printf ( %s is not a vaild device. n , device); //Print Device Name ioctl (fd, EVIOCGNAME (sizeof (name)), name); printf ( Reading From : %s (%s)\n , device, name); while (1){   while(read(fd,&amp;buff,sizeof(struct input_event))==0);   if (buff. value == 1 &amp;&amp; buff. type == 1 &amp;&amp; buff. code != 42){     printf( i:%d,type:%d code:%d value:%d\n ,i,buff. type,buff. code,buff. value);     printf( convert:%c\n ,convert[buff. code]);     convert_value[i]=convert[buff. code];     i++;     if(i == 17){       break;     }   } } printf( %s\n ,convert_value); close(fd); fp = fopen( /tmp/eth_mac. txt ,  w+ ); if(fp == NULL){   printf( OPEN FILE ERROR\n ); } size = sizeof(char); fwrite(convert_value, size, 17, fp); if(rd == EOF){   printf( write eth_mac faile\n ); } rewind(fp); fwrite(convert_value, size, 17, fp); if(rd == EOF){   printf( write eth_mac faile\n ); } fclose(fp);完整的源码https://github. com/yan-wyb/source/tree/master/c/embedded/app/Scanner Picturs link issues如果有疑惑或错误,请提issues –&gt; IssuesIf there are doubts or errors, please submit an issue –&gt; Issues "
    }, {
    "id": 64,
    "url": "/2020/10/28/debug-command.html",
    "title": "调试命令合集",
    "body": "2020/10/28 -  挂载调试文件系统debugfs1$ mount -t debugfs debugfs /sys/kernel/debug验证 12$ mount | grep debugdebugfs on /sys/kernel/debug type debugfs (rw,relatime) 查看USB设备信息节点1$ cat /sys/kernel/debug/usb/devices"
    }, {
    "id": 65,
    "url": "/2020/09/08/automake.html",
    "title": "automake message",
    "body": "2020/09/08 - 正则报错 错误:1Unescaped left brace in regex is illegal here in regex; marked by &lt;-- HERE in m/\${ &lt;-- HERE ([^ \t=:+{}]+)}/ at . . .  解决方法:编辑automake 1$ vim /path/to/automake1$text =~ s/\${([^ \t=:+{}]+)}/substitute_ac_subst_variables_worker ($1)/ge;修改为 1$text =~ s/\$\{([^ \t=:+\{\}]+)\}/substitute_ac_subst_variables_worker ($1)/ge;"
    }, {
    "id": 66,
    "url": "/2020/08/29/ALSA.html",
    "title": "Advanced Linux Sound Architecture",
    "body": "2020/08/29 - ALSA(Advanced Linux Sound Architecture)简单使用 aplay音频播放查看可用音频设备列表: 1234567891011root@root# aplay -l**** List of PLAYBACK Hardware Devices ****card 0: AMLAUGESOUND [AML-AUGESOUND], device 0: SPDIF-dummy-alsaPORT-spdif dummy-0 [] Subdevices: 1/1 Subdevice #0: subdevice #0card 0: AMLAUGESOUND [AML-AUGESOUND], device 1: TDM-B-dummy-alsaPORT-i2s multicodec-1 [] Subdevices: 1/1 Subdevice #0: subdevice #0card 0: AMLAUGESOUND [AML-AUGESOUND], device 2: TDM-A-dummy-alsaPORT-pcm multicodec-2 [] Subdevices: 1/1 Subdevice #0: subdevice #0确定你的音频芯片是哪一个设备,这里以es8316为例,配置在i2s上,则确认为声卡card0,设备1. 使用aplay播放音频: 1root@root# aplay -Dhw:0,1 1. wmv-D指定设备,更多参数可以参照help添加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647root@root# aplay -hUsage: aplay [OPTION]. . . [FILE]. . . -h, --help       help  --version      print current version-l, --list-devices   list all soundcards and digital audio devices-L, --list-pcms     list device names-D, --device=NAME    select PCM by name-q, --quiet       quiet mode-t, --file-type TYPE  file type (voc, wav, raw or au)-c, --channels=#    channels-f, --format=FORMAT   sample format (case insensitive)-r, --rate=#      sample rate-d, --duration=#    interrupt after # seconds-M, --mmap       mmap stream-N, --nonblock     nonblocking mode-F, --period-time=#   distance between interrupts is # microseconds-B, --buffer-time=#   buffer duration is # microseconds  --period-size=#   distance between interrupts is # frames  --buffer-size=#   buffer duration is # frames-A, --avail-min=#    min available space for wakeup is # microseconds-R, --start-delay=#   delay for automatic PCM start is # microseconds            (relative to buffer size if &lt;= 0)-T, --stop-delay=#   delay for automatic PCM stop is # microseconds from xrun-v, --verbose      show PCM structure and setup (accumulative)-V, --vumeter=TYPE   enable VU meter (TYPE: mono or stereo)-I, --separate-channels one file for each channel  --disable-resample disable automatic rate resample  --disable-channels disable automatic channel conversions  --disable-format  disable automatic format conversions  --disable-softvol  disable software volume control (softvol)  --test-position   test ring buffer position  --test-coef=#    test coeficient for ring buffer position (default 8)            expression for validation is: coef * (buffer_size / 2)  --test-nowait    do not wait for ring buffer - eats whole CPU  --max-file-time=#  start another output file when the old file has recorded            for this many seconds  --process-id-file  write the process ID here  --use-strftime   apply the strftime facility to the output file nameRecognized sample formats are: S8 U8 S16_LE S16_BE U16_LE U16_BE S24_LE S24_BE U24_LE U24_BE S32_LE S32_BE U32_LE U32_BE FLOAT_LE FLOAT_BE FLOAT64_LE FLOAT64_BE IEC958_SUBFRAME_LE IEC958_SUBFRAME_BE MU_LAW A_LAW IMA_ADPCM MPEG GSM SPECIAL S24_3LE S24_3BE U24_3LE U24_3BE S20_3LE S20_3BE U20_3LE U20_3BE S18_3LE S18_3BE U18_3LESome of these may not be available on selected hardwareThe availabled format shortcuts are:-f cd (16 bit little endian, 44100, stereo)-f cdr (16 bit big endian, 44100, stereo)-f dat (16 bit little endian, 48000, stereo)arecord音频录制1root@root# arecord -Dhw:0,1 -r8000 -f cd 1. wmv-f指定格式,-r指定频率,-D指定设备. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950root@root# arecord -hUsage: arecord [OPTION]. . . [FILE]. . . -h, --help       help  --version      print current version-l, --list-devices   list all soundcards and digital audio devices-L, --list-pcms     list device names-D, --device=NAME    select PCM by name-q, --quiet       quiet mode-t, --file-type TYPE  file type (voc, wav, raw or au)-c, --channels=#    channels-f, --format=FORMAT   sample format (case insensitive)-r, --rate=#      sample rate-d, --duration=#    interrupt after # seconds-s, --samples=#     interrupt after # samples per channel-M, --mmap       mmap stream-N, --nonblock     nonblocking mode-F, --period-time=#   distance between interrupts is # microseconds-B, --buffer-time=#   buffer duration is # microseconds  --period-size=#   distance between interrupts is # frames  --buffer-size=#   buffer duration is # frames-A, --avail-min=#    min available space for wakeup is # microseconds-R, --start-delay=#   delay for automatic PCM start is # microseconds             (relative to buffer size if &lt;= 0)-T, --stop-delay=#   delay for automatic PCM stop is # microseconds from xrun-v, --verbose      show PCM structure and setup (accumulative)-V, --vumeter=TYPE   enable VU meter (TYPE: mono or stereo)-I, --separate-channels one file for each channel-i, --interactive    allow interactive operation from stdin-m, --chmap=ch1,ch2,. .  Give the channel map to override or follow  --disable-resample disable automatic rate resample  --disable-channels disable automatic channel conversions  --disable-format  disable automatic format conversions  --disable-softvol  disable software volume control (softvol)  --test-position   test ring buffer position  --test-coef=#    test coefficient for ring buffer position (default 8)            expression for validation is: coef * (buffer_size / 2)  --test-nowait    do not wait for ring buffer - eats whole CPU  --max-file-time=#  start another output file when the old file has recorded            for this many seconds  --process-id-file  write the process ID here  --use-strftime   apply the strftime facility to the output file name  --dump-hw-params  dump hw_params of the device  --fatal-errors   treat all errors as fatalRecognized sample formats are: S8 U8 S16_LE S16_BE U16_LE U16_BE S24_LE S24_BE U24_LE U24_BE S32_LE S32_BE U32_LE U32_BE FLOAT_LE FLOAT_BE FLOAT64_LE FLOAT64_BE IEC958_SUBFRAME_LE IEC958_SUBFRAME_BE MU_LAW A_LAW IMA_ADPCM MPEG GSM S20_LE S20_BE U20_LE U20_BE SPECIAL S24_3LE S24_3BE U24_3LE U24_3BE S20_3LE S20_3BE U20_3LE U20_3BE S18_3LE S18_3BE U18_3LE U18_3BE G723_24 G723_24_1B G723_40 G723_40_1B DSD_U8 DSD_U16_LE DSD_U32_LE DSD_U16_BE DSD_U32_BESome of these may not be available on selected hardwareThe available format shortcuts are:-f cd (16 bit little endian, 44100, stereo)-f cdr (16 bit big endian, 44100, stereo)-f dat (16 bit little endian, 48000, stereo)amixer音频设置1root@root# amixer contents会打印出所有的配置参数,获取单个设置值可以使用 1root@root# amixer cget [parameter]打印所有控制选项 1root@root# amixer controls设置选项 1root@root# amixer cset [parameter] [value]更多参数设置方法: 1234567891011121314151617181920212223242526root@root# amixer --helpUsage: amixer &lt;options&gt; [command]Available options: -h,--help    this help -c,--card N   select the card -D,--device N  select the device, default 'default' -d,--debug   debug mode -n,--nocheck  do not perform range checking -v,--version  print version of this program -q,--quiet   be quiet -i,--inactive  show also inactive controls -a,--abstract L select abstraction level (none or basic) -s,--stdin   Read and execute commands from stdin sequentially -R,--raw-volume Use the raw value (default) -M,--mapped-volume Use the mapped volumeAvailable commands: scontrols    show all mixer simple controls scontents    show contents of all mixer simple controls (default command) sset sID P   set contents for one mixer simple control sget sID    get contents for one mixer simple control controls    show all controls for given card contents    show contents of all controls for given card cset cID P   set control contents for one control cget cID    get control contents for one controlissues如果有疑惑或错误,请提issues –&gt; IssuesIf there are doubts or errors, please submit an issue –&gt; Issues "
    }, {
    "id": 67,
    "url": "/2020/08/04/sound-card.html",
    "title": "sound card 调试",
    "body": "2020/08/04 - HDMI以及CVBS的sound card调试记录 查看sound card驱动注册是否成功 切换到root用户123$ suPassword:root@root# 查看是否注册成功123root@root# cat /proc/asound/cards 0 [AMLAUGESOUND  ]: AML-AUGESOUND - AML-AUGESOUND           AML-AUGESOUN正常会打印出注册成功的声卡  删除错误节点注册失败,删除dts里面未使用的声卡节点. 测试HDMI以及CVBS声卡设备 打印出声卡下的可用设备1234567891011121314$ aplay -l**** List of PLAYBACK Hardware Devices ****card 0: AMLAUGESOUND [AML-AUGESOUND], device 0: TDM-B-dummy-alsaPORT-i2s multicodec-0 [] Subdevices: 1/1 Subdevice #0: subdevice #0card 0: AMLAUGESOUND [AML-AUGESOUND], device 1: SPDIF-dummy-alsaPORT-spdif dummy-1 [] Subdevices: 1/1 Subdevice #0: subdevice #0card 0: AMLAUGESOUND [AML-AUGESOUND], device 2: TDM-C-dummy dummy-2 [] Subdevices: 1/1 Subdevice #0: subdevice #0card 0: AMLAUGESOUND [AML-AUGESOUND], device 3: SPDIF-B-dummy-alsaPORT-spdifb dummy-3 [] Subdevices: 1/1 Subdevice #0: subdevice #0 使用aplay调试声卡设备12$ aplay -Dhw:0,0 test. wav #CVBS是声卡0下的设备0$ aplay -Dhw:0,1 test. wav #HDMI是声卡0下设备1这里CVBS是TDM-B-dummy-alsaPORT-i2s,HDMI是SPDIF-dummy-alsaPORT-spdif. 调整dts   只使用HDMI,将HDMI相应的设备节点设置成@0.     使用cvbs和HDMI,CVBS节点为@0,HDMI节点为@1.  issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 68,
    "url": "/2020/08/04/auto-reboot.html",
    "title": "Auto Reboot",
    "body": "2020/08/04 - 设置reboot_mode变量,在uboot和kernel见传递,实现linux下自动重启,用于老化板子使用 uboot定义变量值:  文件路径arch/arm/include/asm/reboot. h1$ vim path/to/u-boot/arch/arm/include/asm/reboot. h定义新的变量值 1#define {board-name}_AUTO_REBOOT    15修改重启命令:  文件路径common/cmd_reboot. c1$ vim path/to/u-boot/common/cmd_reboot. c 添加设置环境变量进函数do_get_rebootmode1234567case AMLOGIC_AUTO_REBOOT:{setenv( reboot_mode , auto_reboot );break;} 在do_reboot函数设置获取kernel重启时传递的值12else if (strcmp(mode,  auto_reboot ) == 0)  reboot_mode_val = AMLOGIC_AUTO_REBOOT; 在U_BOOT_CMD中加入auto_reboot1   auto_reboot\n 添加reboot_mode到storeargs 文件路径path/to/u-boot/board/{chip-board}/configs/{board-name}. h1reboot_mode=${reboot_mode}kernel定义变量值:  修改文件reboot. h1$ vim `path/to/kernel/include/linux/{chip-board}/reboot. h添加自动重启变量定义 1#define MESON_AUTO_REBOOT    15修改驱动:  驱动文件reboot. c1$ vim path/to/kernel/drivers/{chip-board}/reboot/reboot. c添加代码到parse_reason函数 12else if (strcmp(cmd,  auto_reboot ) == 0)  reboot_reason = MESON_AUTO_REBOOT;ubuntu修改cmdline:  文件boot. ini1$ vim path/to/boot. ini 设置rebootmode变量1setenv rebootmode  reboot_mode=${reboot_mode}  添加进启动参数里1${rebootmode}重启脚本文件:  文件路径usr/local/bin1$ vim usr/local/bin/auto-reboot-handle. sh 内容如下:123456#!/bin/bashsleep 15syncreboot -f auto_rebootautoreboot服务:  系统服务文件路径/lib/systemd/system1$ sudo vim lib/systemd/system/auto-reboot. service 内容如下:12345678910111213141516# This file is part of systemd. ## systemd is free software; you can redistribute it and/or modify it# under the terms of the GNU Lesser General Public License as published by# the Free Software Foundation; either version 2. 1 of the License, or# (at your option) any later version. [Unit]Description=auto reboot service#After=systemd-update-utmp-runlevel. service[Service]ExecStart=/usr/local/bin/auto-reboot-handle. sh[Install]WantedBy=multi-user. target修改rc. local:  文件路径etc/rc. local1$ sudo vim etc/rc. local 添加内容123456# Reboot test handleif cat /proc/cmdline | grep -q auto_reboot &gt; /dev/null; then  if ! systemctl is-active auto-reboot | grep  ^active$  &gt; /dev/null; then    systemctl start auto-reboot  fifi重启命令: 1$ sudo reboot -f auto_rebootbuildroot开机运行脚本:  文件路径/etc/init. d/1$ vim /etc/init. d/S98autoreboot 内容如下:1234567#!/bin/bashif cat /proc/cmdline | grep -q auto_reboot &gt; /dev/null; then  sleep 15  sync  reboot -f -tfi修改busybox重启命令:  文件名字halt. c1$ vim path/to/busybox/init/halt. c 修改halt_main函数,添加局部变量定义1char reboot_test = 0; 修改halt_main函数,增加-t参数1flags = getopt32(argv,  d:+nfwit , &amp;delay); --&gt; flags = getopt32(argv,  d:+nfwit , &amp;delay); 修改halt_main函数,修改reboot调用1234567delect:  rc = reboot(magic[which]);add:  if (reboot_test)    rc = reboot(0xA1B2C3D4, 537993216, 0xA1B2C3D4,  reboot_test );  else    rc = reboot(0xA1B2C3D4, 537993216, 0xA1B2C3D4,   );修改busybox头文件:  修改文件reboot. h1$ vim path/to/busybox/init/reboot. h 替换头文件12+//#include &lt;sys/reboot. h&gt;#include &lt;linux/reboot. h&gt;重启命令: 1root@root# reboot -f -t使用-t进入自动重启模式 Source codehttps://github. com/yan-wyb/source/tree/master/c/embedded/combine/auto-reboot issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 69,
    "url": "/2020/07/30/package-deb-error.html",
    "title": "打包deb包碰见的编译错误",
    "body": "2020/07/30 - 记录打包deb包碰见的bug以及解决方法 1. dh报错错误信息: 12345fakeroot debian/rules cleandh clean --with python3 --buildsystem=python_distutilsdh: warning: Compatibility levels before 9 are deprecated (level 7 in use)dh: error: unable to load addon python3: Can't locate Debian/Debhelper/Sequence/python3. pm in @INC (you may need to install the Debian::Debhelper::Sequence::python3 module) (@INC contains: /etc/perl /usr/local/lib/aarch64-linux-gnu/perl/5. 30. 0 /usr/local/share/perl/5. 30. 0 /usr/lib/aarch64-linux-gnu/perl5/5. 30 /usr/share/perl5 /usr/lib/aarch64-linux-gnu/perl/5. 30 /usr/share/perl/5. 30 /usr/local/lib/site_perl /usr/lib/aarch64-linux-gnu/perl-base) at (eval 4) line 1. BEGIN failed--compilation aborted at (eval 4) line 1. 解决方法: 1$ sudo apt install dh-pythonissues如果有疑惑或错误,请提issues –&gt; IssuesIf there are doubts or errors, please submit an issue –&gt; Issues "
    }, {
    "id": 70,
    "url": "/2020/07/23/opencv-in-c++.html",
    "title": "c++上使用opencv",
    "body": "2020/07/23 - opencv支持的图片格式12345678Windows bitmaps - *. bmp, *. dib (always supported)JPEG files - *. jpeg, *. jpg, *. jpe (see the Notes section)JPEG 2000 files - *. jp2 (see the Notes section)Portable Network Graphics - *. png (see the Notes section)WebP - *. webp (see the Notes section)Portable image format - *. pbm, *. pgm, *. ppm (always supported)Sun rasters - *. sr, *. ras (always supported)TIFF files - *. tiff, *. tif (see the Notes section)格式转换cv::Mat –&gt; IplImage*: 12IplImage* pImg*pImg = IplImage(MatImg);IplImage* –&gt; cv::Mat: 1cv::Mat MatImg = cvarrToMat(pImg);12345678910# 读取图片## `cv::Mat` imread()* 函数原型,```c++#include&lt;opencv2/opencv. hpp&gt;Mat cv::imread(const string&amp; filename,int flags=MREAD_COLOR); 参数const string&amp; filename: 图片路径 flags: 读入方式 12345678910111213IMREAD_UNCHANGED      = -1, //返回包含alpha通道的加载图像IMREAD_GRAYSCALE      = 0, //返回一个灰度图像IMREAD_COLOR        = 1, //返回一个BGR通道的图像IMREAD_ANYDEPTH       = 2, //当输入具有相应的深度时返回16位/ 32位图像，否则将其转换为8位。. IMREAD_ANYCOLOR       = 4, //则以任何可能的颜色格式读取图像。IMREAD_LOAD_GDAL      = 8, //使用GDAL的驱动加载图像。IMREAD_REDUCED_GRAYSCALE_2 = 16, //将图像转换为单通道灰度图像，图像大小减少1/2。IMREAD_REDUCED_COLOR_2   = 17, //转换图像的3通道BGR彩色图像和图像的大小减少1/2。IMREAD_REDUCED_GRAYSCALE_4 = 32, //将图像转换为单通道灰度图像，图像大小减少1/4。IMREAD_REDUCED_COLOR_4   = 33, //转换图像的3通道BGR彩色图像和图像的大小减少1/4。IMREAD_REDUCED_GRAYSCALE_8 = 64, //将图像转换为单通道灰度图像，图像大小减少1/8。IMREAD_REDUCED_COLOR_8   = 65, //转换图像的3通道BGR色彩图像和图像大小减少1/8。IMREAD_IGNORE_ORIENTATION  = 128 //不旋转图像根据EXIF的定位标志。IplImage* cvLoadImage():  原型12#include &lt;opencv2/imgcodecs/imgcodecs_c. h&gt;IplImage* cvLoadImage( const char* filename, int flags=CV_LOAD_IMAGE_COLOR ) 参数const char* filename: 图片路径 flags: 读入方式 123456CV_LOAD_IMAGE_UNCHANGEDCV_LOAD_IMAGE_GRAYSCALECV_LOAD_IMAGE_COLORCV_LOAD_IMAGE_ANYDEPTHCV_LOAD_IMAGE_ANYCOLORCV_LOAD_IMAGE_IGNORE_ORIENTATION cvDecodeImageM()使用cvDecodeImageM()函数返回cv::Mat格式 显示图片namedWindow():  函数原型12#include &lt;opencv2/highgui/highgui. hpp&gt;void cv::namedWindow(const String &amp; winname,int flags = WINDOW_AUTOSIZE)	 参数const String &amp; winname: 窗口的标识名称 flag: 窗口的生成方式 12345678910111213CV_WND_PROP_FULLSCREEN 	CV_WND_PROP_AUTOSIZE 	CV_WND_PROP_ASPECTRATIO 	CV_WND_PROP_OPENGL 	CV_WND_PROP_VISIBLE 	CV_WINDOW_NORMAL 	CV_WINDOW_AUTOSIZE 	CV_WINDOW_OPENGL 	CV_GUI_EXPANDED 	CV_GUI_NORMAL 	CV_WINDOW_FULLSCREEN 	CV_WINDOW_FREERATIO 	CV_WINDOW_KEEPRATIO imshow():  函数原型12#include &lt;opencv2/highgui/highgui. hpp&gt;void imshow(const string&amp; winname,InputArray mat); 参数const string&amp; winname: 窗口的标识名称 InputArray mat: 显示的图片的矩阵数据 创建图片cvCreateImage 函数原型1IplImage* cvCreateImage(CvSize cvSize(int width, int height), int depth, int channels); 参数depth: 图像元素深度值 1234567IPL_DEPTH_8U - 无符号8位整型IPL_DEPTH_8S - 有符号8位整型IPL_DEPTH_16U - 无符号16位整型IPL_DEPTH_16S - 有符号16位整型IPL_DEPTH_32S - 有符号32位整型IPL_DEPTH_32F - 单精度浮点数IPL_DEPTH_64F - 双精度浮点数channels: 通道值,可以是1,2,3,4 示例源码   识别图片,显示识别结果     摄像头识别  官方文档https://docs. opencv. org/ issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 71,
    "url": "/2020/07/21/connect-wifi.html",
    "title": "buildroot如何连接wifi",
    "body": "2020/07/21 - wpa_cli使用wpa_cli命令直接连接wifi,重启即失效. 12345678buildroot# wpa_cli -i wlan0 add_network0buildroot# wpa_cli -i wlan0 set_network 0 ssid ' XXX 'buildroot# wpa_cli -i wlan0 set_network 0 key_mgmt WPA-PSKbuildroot# wpa_cli -i wlan0 set_network 0 psk ' XXXXXXXX 'buildroot# wpa_cli -i wlan0 select_network 0buildroot# wpa_cli -i wlan0 enable_network 0buildroot# dhcpcd wlan0wpa_supplicant修改配置文件: 1buildroot# nano /etc/wpa_supplicant示例如下 1234567891011ctrl_interface=/var/run/wpa_supplicantctrl_interface_group=0ap_scan=1network={  ssid=”myAP” pairwise=CCMP TKIP  group=CCMP TKIP  proto=WPA RSN  key_mgmt=WPA-PSK  priority=5  psk=”my_passwd”}重启服务: 直接重启整个wifi服务 1buildroot# /etc/init. d/S42wifi reload或者 1buildroot# wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant. conf重启dhcpcd: 1buildroot# dhcpcdissues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 72,
    "url": "/2020/07/18/device-tree-compiler.html",
    "title": "device-tree-compiler",
    "body": "2020/07/18 - device-tree-compiler 是用于dts和dtb的工具合集 安装这里以APT源为例 1$ sudo apt-get install device-tree-compiler编译和反编译dtc命令用于编译dts和反编译dtb dtb反编译成dts: 12$ cd ${workspace} &amp;&amp; lsfilename. dtb-I参数指定源,-O参数指定目标格式为dts 1$ dtc -I dtb -O dts filename. dtb &gt; filename. dts或者 1$ dtc filename. dtb &gt; filename. dtsdts编译成dtb: 12$ cd ${workspace} &amp;&amp; lsfilename. dts-O指定目标格式为dtb 1$ dtc -O dtb -o filename. dtb filename. dts或者 1$ dtc filename. dts &gt; filename. dtb修改dtb的节点fdtget和fdtput用于读取和修改dtb 读取节点状态: 1234$ cd ${workspace} &amp;&amp; lsfilename. dtb$ fdtget filename. dtb /onewire statusokay修改节点状态: 12345$ cd ${workspace} &amp;&amp; lsfilename. dtb$ fdtput -t s filename. dtb /onewire status  disable $ fdtget filename. dtb /onewire statusdisablenote: 有的节点修改完需要reboot才能生效 比较dtb区别dtdiff命令,用于比较不同dtb之间的区别 123456789101112131415161718$ cd ${workspace} &amp;&amp; lsfilename. dtb$ fdtget filename. dtb /onewire statusokay$ cp filename. dtb filename2. dtb$ fdtput -t s filename2. dtb /onewire status  disable $ dtdiff filename. dtb filename2. dtb--- /dev/fd/63 2020-07-18 02:27:13. 437617744 +0000+++ /dev/fd/62 2020-07-18 02:27:13. 437617744 +0000@@ -1703,7 +1703,7 @@        compatible =  w1-gpio ;        gpios = &lt;0x1b 0x17 0x0&gt;;        phandle = &lt;0x10a&gt;;-        status =  okay ;+        status =  disable ;    };    p_tsensor@ff634594 {读取dtb头部和节点信息fdtdump工具可用于读取dtb的头部信息和节点信息 12345678910111213$ fdtdump -sd filename. dtb &gt; dump. txt$ cat dump. txt(这里是部分打印信息)// magic:        0xd00dfeed// totalsize:      0x15a8b (88715)// off_dt_struct:    0x38// off_dt_strings:   0x1394c// off_mem_rsvmap:   0x28// version:       17// last_comp_version:  16// boot_cpuid_phys:   0x0// size_dt_strings:   0x213f// size_dt_struct:   0x13914覆盖dtb节点fdtoverlay用于覆盖设备节点 1234567891011121314$ fdtoverlay -hUsage: apply a number of overlays to a base blob    fdtoverlay &lt;options&gt; [&lt;overlay. dtbo&gt; [&lt;overlay. dtbo&gt;]]&lt;type&gt; s=string, i=int, u=unsigned, x=hex    Optional modifier prefix:        hh or b=byte, h=2 byte, l=4 byte (default)Options: -[i:o:vhV] -i, --input &lt;arg&gt; Input base DT blob -o, --output &lt;arg&gt; Output DT blob -v, --verbose   Verbose messages -h, --help     Print this help and exit -V, --version   Print version and exitissues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 73,
    "url": "/2020/07/17/01-Wire-driver.html",
    "title": "增加单总线支持",
    "body": "2020/07/17 - 通过GPIO连接控制单总线 dts配置12345 onewire:onewire {   compatible =  w1-gpio ;   gpios = &lt;&amp;gpio GPIOH_6 GPIO_ACTIVE_HIGH&gt;;   status =  disable ;};内核配置123CONFIG_W1=y          #打开总线配置CONFIG_W1_MASTER_GPIO=y    #配置到GPIOCONFIG_W1_SLAVE_THERM=y    #打开w1_salve用于读取值使用以ds18b20为例 123456789$ cd /sys/bus/w1/devices$ ls28-0119395ebf91 w1_bus_master1$ cd 28-0119395ebf91$ lsdriver id name power subsystem uevent w1_slave$ cat w1_slave b1 01 4b 46 7f ff 0c 10 d8 : crc=d8 YESb1 01 4b 46 7f ff 0c 10 d8 t=27062注意 单总线设备不支持热插拔 issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 74,
    "url": "/2020/07/08/deb.html",
    "title": "deb包管理",
    "body": "2020/07/08 - deb包是DEBIAN系linux操作系统的系统包格式,也是APT源安装的包格式 deb包管理使用安装deb包: 1$ sudo dpkg -i ${filename}. deb小部分不需要安装到系统文件夹的deb包不需要sudo权限安装. 示例: 123$ cd ${workspace}$ wget https://github. com/yan-wyb/somethingelse/raw/master/tools/ubuntu18x64-scrt. deb$ sudo dpkg -i ubuntu18x64-scrt. deb出现依赖未安装的错误,可通过APT命令解决 1$ sudo apt install -f或者通过APT命令安装deb,可同时解决依赖问题 1$ sudo apt install . /ubuntu18x64-scrt. deb查看已经安装的包: 1$ sudo dpkg -l通常这样子会打印出相当多的包,最好通过grep过滤 1$ sudo dpkg -l | grep  ${filename} 示例 12$ sudo dpkg -l | grep  scrt ii scrt                            8. 5. 4-1942                    amd64    SecureCRT提取deb包源码: 1$ sudo dpkg -x ${filename}. deb ${filename}在${filename}文件里的文件就是源码问题 示例 1234$ cd ${workspace}$ sudo dpkg -x ubuntu18x64-scrt. deb ubuntu18x64-scrt$ ls ubuntu18x64-scrtusr提取DEBIAN编译规则: 1$ sudo dpkg -e ${filename}. deb ${filename}/DEBIAN示例: 1234$ cd ${workspace}$ sudo dpkg -e ubuntu18x64-scrt. deb ubuntu18x64-scrt/DEBIAN$ ls ubuntu18x64-scrt/DEBIANconffiles control打包deb包: 1$ sudo dpkg -b ${filename}打包的时候,应该确认DEBIAN的编译规则是否被包括在里面了,即${filename}/DEBIAN 12345678$ cd ${workspace}$ rm ubuntu18x64-scrt. deb$ lsubuntu18x64-scrt$ sudo dpkg -b ubuntu18x64-scrt/dpkg-deb: building package 'scrt' in 'ubuntu18x64-scrt. deb'. $ ls ubuntu18x64-scrt ubuntu18x64-scrt. deb创建自己的deb包issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 75,
    "url": "/2020/06/18/diskpart.html",
    "title": "diskpart工具",
    "body": "2020/06/18 - diskpart是windows格式化磁盘如SSD,U盘等介质的专业工具 有时候,特别是需要在linux和windows中来回切换的人,一旦在linux下格式化磁盘,时长会发现插回windows后,磁盘空间变小了很多,这时候,使用diskpart重新格式化才能使用被隐藏的空间 Step1: 打开diskpart用win+R的组合按键打开Run,然后输入cmd,打开控制终端 在终端上输入diskpart,打开diskpart工具 Step2: 选中磁盘查看disk列表 1list disk选择所要格式话的磁盘 1select disk ${num}Step3: 清除磁盘1cleanStep4: 设置分区1create partition primary激活 1activeStep5: 格式化格式有三种,可以选择任意一种,label为格式化后的磁盘的名字,quick为快速格式化,是可选项 1format fs=${ntfs/exFAT/FAT} label= ${name}  quick分配磁盘盘符 1assign完整过程 issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 76,
    "url": "/2020/06/17/python-call-c.html",
    "title": "python调用C接口",
    "body": "2020/06/17 - python主要通过ctype与C语言进行接口对接,这里是常用的对接方法 数据类型对照表 加载链接库python调用C的函数,绝大多数情况都是调用的链接库文件里面的函数接口 12from ctypes import *c_so = CDLL('/path/to/c. so')通过CDLL函数就能解析so库,返回相应的库对象,调用里面的函数接口时, 1c_so. func(arg1, arg2, . . . )结构体在python中是没有结构体概念的,所以唯一的方法就是设计一个相应的类,在调用时去对应结构体的结构体成员. 新建一个class,声明为Structure,结构如下 123class class_name(Structure):  _fields_ = [  ]示例: 12345678class image(Structure):    _fields_ = [        ('data',c_char_p),        ('pixel_format',c_int),        ('width',c_int),        ('height',c_int),        ('channel',c_int)    ]对应的结构体 1234567typedef struct input_image { unsigned char *data;      ///&lt;picture data ptr value det_pixel_format pixel_format; ///&lt; color format int width;           ///&lt; width value of pixel int height;           ///&lt; height value of pixel int channel;          ///&lt; stride or channel for picture} input_image_t;枚举1234class class_name(Enum):  cytpes_enum0 = 0  ctypes_enum1  . . . 示例: 123456789class det_pixel_format(Enum):    PIX_FMT_GRAY8 = 0    PIX_FMT_YUV420P = 1    PIX_FMT_NV12 = 2    PIX_FMT_NV21 = 3    PIX_FMT_BGRA8888 = 4    PIX_FMT_BGR888 = 5    PIX_FMT_RGBA8888 = 6    PIX_FMT_RGB888 = 7对应的C的枚举 1234567891011121314151617181920212223typedef enum { ///&lt; Y 1 8bpp(Single channel 8bit gray pixels ) PIX_FMT_GRAY8, ///&lt; YUV 4:2:0 12bpp ( 3 channels, one brightness channel, the othe /// two for the U component and V component channel, all channels are continuous) PIX_FMT_YUV420P, ///&lt; YUV 4:2:0 12bpp ( 2 channels, one channel is a continuous /// luminance /// channel, and the other channel is interleaved as a UV component ) PIX_FMT_NV12, ///&lt; YUV 4:2:0    12bpp ( 2 channels, one channel is a continuous /// luminance /// channel, and the other channel is interleaved as a UV component ) PIX_FMT_NV21, ///&lt; BGRA 8:8:8:8   32bpp ( 4-channel 32bit BGRA pixels ) PIX_FMT_BGRA8888, ///&lt; BGR 8:8:8    24bpp ( 3-channel 24bit BGR pixels ) PIX_FMT_BGR888, ///&lt; RGBA 8:8:8：8  32bpp ( 4-channel 32bit RGBA pixels ) PIX_FMT_RGBA8888, ///&lt; RGB 8:8:8    24bpp ( 3-channel 24bit RGB pixels ) PIX_FMT_RGB888} det_pixel_format;函数接口对接1. 获取对应的函数接口 12c_so = CDLL('/path/to/c. so')get_c_func = c_so. c_func2. 设置参数类型 1get_c_func. argtypes = [c_types . . . ]3. 调用,参数传入时转换类型 1get_c_func(c_types(arg1) . . . )示例: 12345678def get_model_size(self, det_type, width,height,channel):      det_get_model_size = self. detect_so. det_get_model_size  /*This is step1*/      det_get_model_size. argtypes = [c_int,POINTER(c_int),POINTER(c_int),POINTER(c_int)] /*This is step2*/      GET_MODEL_SIZE_STATUS = det_get_model_size(c_int(det_type),              pointer(width),pointer(height),pointer(channel))  /*This is step3*/      if GET_MODEL_SIZE_STATUS :          sys. exit('get model size fail !')      return width,height,channel对应的C函数 12345678910111213141516det_status_t det_get_model_size(det_model_type modelType, int *width, int *height, int *channel){  LOGP( Enter, modeltype:%d , modelType);  int ret = DET_STATUS_OK;  p_det_network_t net = &amp;network[modelType];  if (!net-&gt;status) {    LOGE( Model has not created! modeltype:%d , modelType);    _SET_STATUS_(ret, DET_STATUS_ERROR, exit);  }  net-&gt;process. model_getsize(width, height, channel);exit:  LOGP( Leave, modeltype:%d , modelType);  return ret;}示例源码Git地址: https://github. com/yan-wyb/source/tree/master/python/ctypes 官方手册官方手册 : https://docs. python. org/3/library/ctypes. html issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 77,
    "url": "/2020/06/16/ubuntu-basic.html",
    "title": "Ubuntu 20.04 配置",
    "body": "2020/06/16 - 搜狗输入法Ubuntu20. 04 不再支持QT4,所以原本依赖QT4的搜狗输入法,目前无法安装在20. 04上,目前有一个社区开发者从企业定制版本中抽取出来了一个可用版本 1234$ cd ${workspace}$ wget https://github. com/yan-wyb/somethingelse/raw/master/tools/sogouimebs. deb$ sudo apt install . /sogouimebs. deb系统会自动安装依赖,其中就包括fcitx. 接下来设置 –&gt; 打开Language Supports.  将Keyboard imput method system设置成fcitx.  然后重启,就会在右上角看到键盘的设置.  点击左下角的+号,不要勾选Only Show Current Language. 搜索sogou,点击添加 tweakstweaks是用来管理UI的最好用的工具之一 123$ sudo apt upate$ sudo apt install gnome-shell-extensions$ sudo apt install gnome-tweak-tool 配置以后先打开user themes,然后重启软件, 重启软件就可以配置主题,图标,终端风格,壁纸等 dockydocky是仿IOS风格的dock工具 123456789$ cd ${workspace}$ wget http://archive. ubuntu. com/ubuntu/pool/universe/g/gnome-sharp2/libgconf2. 0-cil_2. 24. 2-4_all. deb$ wget http://archive. ubuntu. com/ubuntu/pool/main/g/glibc/multiarch-support_2. 27-3ubuntu1_amd64. deb$ wget http://archive. ubuntu. com/ubuntu/pool/universe/libg/libgnome-keyring/libgnome-keyring-common_3. 12. 0-1build1_all. deb$ wget http://archive. ubuntu. com/ubuntu/pool/universe/libg/libgnome-keyring/libgnome-keyring0_3. 12. 0-1build1_amd64. deb$ wget http://archive. ubuntu. com/ubuntu/pool/universe/g/gnome-keyring-sharp/libgnome-keyring1. 0-cil_1. 0. 0-5_amd64. deb$ sudo apt-get install . /*. deb$ wget http://archive. ubuntu. com/ubuntu/pool/universe/d/docky/docky_2. 2. 1. 1-1_all. deb$ sudo apt-get install . /docky_2. 2. 1. 1-1_all. deb 安装完成以后,可以删除下载的deb 12$ cd ${workspace}$ rm *. deb截图linux下的截图工具很多,但是Gnome桌面自带的截图工具就非常好用 1$ gnome-screenshot只想截图一部分,可以带上-a参数 1$ gnome-screenshot -a设置成快捷键 Setting --&gt; Keyboard,点击+添加一个新的快捷键,填入name和command VirtualBoxubuntu20. 04通过APT源直接安装就可以安装最新的virtualBox 1234$ sudo apt update$ sudo apt install build-essential$ sudo apt install virtualbox$ sudo apt install virtualbox-ext-pack设置USB读写权限 123$ sudo groupadd usbfs$ sudo adduser $USER vboxusers$ sudo adduser $USER usbfsnote: BIOS中source boot不能打开,如果打开了请关闭后加上--reinstall重新安装 Sublime Text123$ wget -qO - https://download. sublimetext. com/sublimehq-pub. gpg | sudo apt-key add -$ sudo apt-add-repository  deb https://download. sublimetext. com/ apt/stable/ $ sudo apt install sublime-text串口工具添加USB权限1$ sudo usermod -a -G dialout $(whoami)注销或者重启以后生效 SecureCRT12$ wget https://github. com/yan-wyb/somethingelse/raw/master/tools/Ubuntu20. 04_SecureCRT. 7z$ 7z x Ubuntu20. 04_SecureCRT. 7z参考readme安装 issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 78,
    "url": "/2020/06/13/ssl.html",
    "title": "ssl申请与配置",
    "body": "2020/06/13 - 配置使用linux基金会的开源ssl证书Let's Encrypt  Let’s Encrypt 证书不仅是免费的，而且支持通配符证书(通配符证书指的是一个可以被多个子域名使用的公钥证书),多个子域名使用起来十分方便。 通过源码的脚本可以直接获取,申请流程非常简单.  证书有效期为90天,通过脚本可以直接更新. 服务器设置以阿里云为例,其他服务器配置方式相同 433端口设置: 登录服务器控制台,确认实例的安全组里,433端口是否有开放,没有需要添加一条规则 域名解析设置: 域名需要设置一条解析记录,以便申请工具通过域名访问,确认域名所属  选择记录类型,一般选A,指向ipv4地址,如果你是用ipv6地址,选择AAAA,域名重定向,选择CNAME.  主机记录,选择www或者@或者其他都可以. 这里需要记住你的主机记录,之后会用到.  你的域名 记录值选择你要解析的ip地址 TTL使用默认值就可以. 服务器端口处理: 脚本在生成ssl证书时,需要使用到80和433端口,要保证端口没有被占用 12345678$ sudo netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address      Foreign Address     State    PID/Program name  tcp    0   0 0. 0. 0. 0:80       0. 0. 0. 0:*        LISTEN   623/nginx: master p tcp    0   0 127. 0. 0. 53:53      0. 0. 0. 0:*        LISTEN   467/systemd-resolve tcp    0   0 0. 0. 0. 0:22       0. 0. 0. 0:*        LISTEN   572/sshd      tcp    0   0 0. 0. 0. 0:443       0. 0. 0. 0:*        LISTEN   623/nginx: master p 使用kill命令结束掉使用80与433端口的进程 1$ sudo kill [PID]到这里,服务器的准备工作就完成了 申请获取脚本文件: 脚本开源在了github上,通过git克隆仓库到本地 123$ cd ${workspace}$ git clone https://github. com/certbot/certbot$ cd certbot生成证书: 1$ . /certbot-auto certonly --webroot --agree-tos -v -t --email ${email} -w ${website root} -d ${domain name} ${email} 这里填写你的邮箱地址,建议与服务器的申请账号的邮箱地址保持一致 ${website root} 你的网页源码目录 ${domain name} 上面解析域名时,你设置的解析域名,如果主机记录设置了www,这里应该是www. {domain name},设置了@,就直接填写域名如果你上面的设置都没问题,那么这里,问题就应该成功生成证书了 12root# ls /etc/letsencrypt/live/`${domain name}`/cert. pem    chain. pem   fullchain. pem privkey. pem  README生成dhparams: dhparams保证双方能安装的交换秘钥 1$ openssl dhparam -out /etc/ssl/certs/dhparams. pem 2048配置准备好证书以后,就要配置进部署工具里,这里以nginx为例 123456789101112131415161718192021server {    listen 80;    server_name ${domain name} www. ${domain name};    return 301 ${domain name}$request_uri;}server {    listen 443 ssl;    server_name ${domain name} www. ${domain name};    ssl on;    ssl_certificate /etc/letsencrypt/live/${domain name}/fullchain. pem;    ssl_certificate_key /etc/letsencrypt/live/${domain name}/privkey. pem;    ssl_dhparam /etc/ssl/certs/dhparams. pem;    ssl_protocols SSLv3 TLSv1 TLSv1. 1 TLSv1. 2;    ssl_ciphers HIGH:!aNULL:!MD5;    location / {       root ${website root};       index index. html index. htm;    }}重启nginx服务即可 更新证书证书有效期是90天,需要定期更新 1$ . /certbot-auto renew -vother完整的nginx配置文件: https://github. com/yan-wyb/source/blob/master/web/nginx/nginx. conf issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 79,
    "url": "/2020/06/10/compression-tool.html",
    "title": "压缩解压工具",
    "body": "2020/06/10 - tar/gz/bz这些是linux系统自带的解压 . tar 12$ tar zxvf file. tar$ tar czvf file. tar file. gz 12$ gunzip file. gz / gzip -d file. gz$ gzip file. tar. gz (. tgz) 12$ tar zxvf file. tar. gz$ tar zcvf file. tar. gz file1 file2 . . . . . bz2 12$ bzip2 -d file. bz2 / bunzip2 file. bz2$ bzip2 -z file. tar. bz2 12$ tar jxvf file. tar. bz2$ tar jcvf file. tar. bz2 file. tar. xz 12$ xz -d file. tar. xz --&gt; tar xvf file. tar$ tar cvf file. tar file --&gt; xz -z file. tarrar安装rar. 以APT源为例 12$ sudo apt update$ sudo apt install unrar解压和压缩 12$ unrar e file. rar$ rar a file7z安装7z,以APT源为例 1$ sudo apt install p7zip-full解压与压缩 12$ 7z x file. 7z -r -o file$ 7z a -t7z -r file. 7z filezip/unzip安装zip/unzip,以APT源为例 12$ sudo apt update$ sudo apt install zip unzip解压与压缩 12$ zip -r file. zip file$ unzip file. zip超大文件压缩成多个文件123$ rar a -v50m(50k) file. rar file$ tar cjf - file |split -b 50m - file. tar. bz2$ 7z a file. 7z file -v2048missues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 80,
    "url": "/2020/06/09/githooks.html",
    "title": "githooks自动部署",
    "body": "2020/06/09 - githooks实现自动部署到服务器 简述travis只能部署开源的项目,并且travis部署过程中出现问题,极其难以调试,对账号和服务器都有安全风险,并且使用travis,源仓库就不能放在服务器上. 如果是部署在服务器上,无论是开源还是闭源项目,githooks都是简单好用且安全的方法  在服务器上设置好githooks 本地push代码触发hooks,完成自动部署使用traivs自动化部署可参考–&gt; travis实现自动化部署 环境准备主要是服务器上关于git的设置 服务器: 服务器使用阿里云或者腾讯云都可以,配置基本可以走最低配置,大多数时候只跑一个nginx而已. 系统选择ubuntu或者centos. 下面以ubuntu18. 04的阿里云为例 登录服务器以后先更新系统 12root# apt update root# apt upgrade为了避免安全风险,应该先建立一个带有sudo权限的普通用户部署博客. 按照linux新建用户里面的方法新建. 之后所有操作切换到普通用户进行. git: 安装git: 服务器上需要安装git工具 1$ sudo apt install git nginx: ngix在服务器上的安装与设置请参考Nginx安装配置 配置好环境以后,root的路径先不用配置 部署过程主要是生成hooks Repositories,触发后编译静态网页,nginx部署 生成hooks Repositories: 这一步的操作在服务器上完成 12$ cd ${workspace}$ git init --bare ${hooks-name}. git在git init时加上--bare参数声明生成的仓库是一个空的bare仓库,这个仓库就是我们要使用的githooks仓库 1$ cd ${workspace}/${hooks-name}. git/hooks这里就是存放触发脚本的地方,在此目录下新建触发脚本post-receive. 设置执行权限chmod +x post-receive 进入你想要放置源码的目录 1$ cd ${sourcespace}将githooks仓库clone过来 1$ git clone ${workspace}/${hooks-name}. git ${sourcespace}目录会多出一个${hooks-name}文件夹. 以后,每次推送代码触发hooks,hooks机会将代码同步到这个文件夹 回到githooks目录,设置触发脚本,内容如下 12345678910#!/bin/bashunset GIT_DIRNowPath=`pwd`DeployPath= ${sourcespace}/${hooks-name} cd $DeployPathgit config user. email ${email}git config user. name ${user}git add . -A &amp;&amp; git stashgit pull origin masterbash ${script-name}. sh其中${script-name}. sh是触发hooks,同步完代码以后执行的脚本,你可以在里面添加你想要执行的任意代码,如编译静态网页等 本地Repositories设置: 12$ cd ${sourcesapce}$ mkdir ${script-name}. sh在里面添加编译的脚本,如 1234567# jekyllbundle install jekyll build# hexonpm installnpm build然后git commit提交代码. 开始添加远程仓库 1$ git remote add ${hooks} ${user}@${youripaddr}:${workspace}/${hooks-name}. git 添加完以后push代码 1$ git push ${hooks} master服务器上的hooks接收push代码以后,就会同步到${sourcespace}/${hooks-name},同时执行${script-name}. sh. 完成自动编译 nginx部署: 在nginx配置文件中将目录指向编译生成的_site 12345location / {            root ${sourcespace}/${hooks-name}/site;            index index. html index. htm;        }整个自动化部署流程就结束了,以后每次在本地push代码都会触发自动化部署 多人协作一般一个复杂的项目可能由多人完成,每个人只负责其中一部分. 也值需要更新一部分,每个人的执行脚本可能都不一样,那么每个人都可以在服务器上生成自己的githooks仓库. 然后在${sourcespace}下git clone多个hooks仓库就能实现多人协作自动部署 但是避免代码混乱,建议还是使用相同的hooks,这样子源码不会出现无法commit的情况 note ${}都需要进行替换issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 81,
    "url": "/2020/06/08/jekyll-travis.html",
    "title": "jekyll自动部署",
    "body": "2020/06/08 - 使用travis自动部署jekyll博客到服务器或者github-pages 部署到服务器简述:  授权travis读写和监测仓库的权限 本地到push代码到远程触发travis travis通过ssh登录服务器自动同步代码编译新的静态网页代码 nginx实现部署自动化部署私有仓库到服务器或者源仓库就在服务器可使用githooks –&gt; githooks自动化部署 环境准备: 这步主要是设置服务器的环境和travis对github的授权获取 服务器: 服务器使用阿里云或者腾讯云都可以,配置基本可以走最低配置,大多数时候只跑一个nginx而已. 系统选择ubuntu或者centos. 下面以ubuntu18. 04的阿里云为例 登录服务器以后先更新系统 12root# apt update root# apt upgrade为了避免安全风险,应该先建立一个带有sudo权限的普通用户部署博客. 按照linux新建用户里面的方法新建. 之后所有操作切换到普通用户进行. git: 服务器上需要安装git工具 1$ sudo apt install git克隆你的blog到服务器 12$ cd ${workspace}$ git clone git@github. com:/${user}/&amp;{your-blog}. gitgithub上的该仓库需要设置成开源,travis对私有项目部署是收费的 ruby: 在服务器上安装ruby环境请参考Ruby安装使用 安装完以后需要安装三个ruby包 1$ gem install jekyll bundler travis其他的包后续使用bundle install可以自动完成 nginx: ngix在服务器上的安装与设置请参考Nginx安装配置 配置好环境以后,root的路径先不用配置 ssh: ssh在服务器上的安装请参照ssh安装使用 然后生成一对秘钥待使用 travis: 首先要使用github登录travis. 打开setting 然后同步账号的仓库信息 接着打开你要自动部署的仓库 实现自动部署: 切换到你的blog路径 1$ cd ${workspace}/${your-blog}基本自动部署脚本: 新建. travls. yml 1$ vim . travis. yml123456789language: rubyrvm:- 2. 7. 0branches: only: - masterinstall:- bundle installscript: jekyll buildtarvis login: 123456789$ travis loginWe need your GitHub login to identify you. This information will not be sent to Travis CI, only to api. github. com. The password will not be displayed. Try running with --github-token or --auto if you don't want to enter your password anyway. Username: ${your/github/user}password: {your/github/password}出现success就是登录成功 生成保密key: 1$ travis encrypt-file ~/. ssh/id_rsa --add按照提示操作,就会生成id_rsa. enc文件,同时在. travis文件里会生成 123before_install:- openssl aes-256-cbc -K $encrypted_ebb8fbb5669e_key -iv $encrypted_ebb8fbb5669e_iv -in id_rsa. enc -out ~/. ssh/id_rsa -d设置自动部署脚本: travis检测到新提交并成功isntall以后,登录服务器,进行我们自动部署的步骤 这里我在根目录新建. travis目录,把travis相关文件放置到这个文件夹下 1$ mv id_rsa. enc . travis修改. travis. yml文件 1234before_install:- openssl aes-256-cbc -K $encrypted_ebb8fbb5669e_key -iv $encrypted_ebb8fbb5669e_iv -in id_rsa. enc -out ~/. ssh/id_rsa -d修改为 1234before_install:- openssl aes-256-cbc -K $encrypted_ebb8fbb5669e_key -iv $encrypted_ebb8fbb5669e_iv -in . travis/id_rsa. enc -out ~/. ssh/id_rsa -d在文件最后新增after_success: 123atfer_success:- chmod 600 ~/. ssh/id_rsa- ssh {user}@xx. x. xx. x -o StrictHostKeyChecking=no 'cd ~/blog/Avalon &amp;&amp; bash . travis/deploy. sh &amp;&amp; exit'在. travis文件加下新建deploy. sh脚本 12$ vim . travis/deploy. sh内容如下 1234567891011121314set -euxo pipefailecho -e  \033[32m $(git version) \033[0m git config user. name ${user}git config user. email ${email}cd ${workspace}/{your-blog}git pull origin master~/. rvm/gems/ruby-2. 7. 0/wrappers/bundle install~/. rvm/gems/ruby-2. 7. 0/wrappers/jekyll buildexit 0nginx部署: 在nginx配置文件中将目录指向编译生成的_site 12345location / {            root ${workspace}/${your-blog}/_site;            index index. html index. htm;        }自此,整个自动部署流程就结束了,之后每次push代码,travis都会自动检测并登录服务器进行更新 部署到github pages简述:  授权travis读写和监测仓库的权限 本地到push代码到远程触发travis travis编译完以后push到仓库的’gh-pages’分支 githubio完成部署准备环境: 主要完成本地PC环境的部署和github对travis的授权 ssh: 在本地安装ssh，将生成的公钥放上个github。请参照ssh安装使用 ruby: 在本地环境中安装ruby环境请参考Ruby安装使用 安装完需要在本地环境中安装3个ruby包 1$ gem install jekyll bundler travisgit: Repositories设置: 首先要在github上把项目设置成public,travis只对开源项目免费，然后将项目clone到本地 note : 这里一定要使用ssh的方式clone下来,不能使用https. 12$ cd ${workspace}$ git clone git@github. com:${user}/{your-blog}. git之后需要新建gh-pages分支,同时推送到远端 12$ git branch gh-pages$ git push origin pg-pages打开github pages: 打开仓库的setting 在列表中找到github pages,设置成gh-pages分支 travis: 首先要使用github登录travis. 打开setting 然后同步账号的仓库信息 接着打开你要自动部署的仓库 实现自动部署: 与部署到服务器不同,部署到github pages我们借用了rake实现自动部署 github生成新的token: 在使用github登陆travis时实际上已经生成了一个token,但是这个token没有写repo的权限，因此需要生成新的token  打开github的setting --&gt; Development Settings.  点击左边最底下的Personal access token,在右上角就会看到Generate new token.  为即将生成的新token设置note，相当于标识，或者别名  设置token的权限 5. 记下token的值，这个值只有第一次生成时会显示，之后就不会再显示了，因此生成时一定要复制下来 token生成密钥: 使用git账号登录travis 123456789$ travis loginWe need your GitHub login to identify you. This information will not be sent to Travis CI, only to api. github. com. The password will not be displayed. Try running with --github-token or --auto if you don't want to enter your password anyway. Username: ${your/github/user}password: {your/github/password}利用travis的ruby包可以生成包含token的密钥 12345678910$ travis encrypt 'GIT_NAME= ${user}  GIT_EMAIL= ${email}  GH_TOKEN=${token}'Detected repository as ${user}/${your-blog}, is this correct? |yes| yesPlease add the following to your . travis. yml file: secure:  N/5TqXrxjS0J6yKvRlzXnuYtfRPFYeK/O2oumIMuCWTK9U9v54pBTyOhiuCvoS5zJkxa4hdQwXs+wdIBDimILPu1JqQEhtjqLC2toK3vMNgf76KE6G+FtBzpEOrjA8vsEALNGlh5LH8n9XkeCDzXgFx3bghMXKms/EOlnR+21Un3SQVDAvuNK32VLexokTxy9nDZ769kTD5ymvP7DU5ObzdstnMeYY5SDAllPOPI2FboQbU1bg71P2LRvc3aF+Gu3X95pVoUSRPqAuJhnPp1DyXW0ifC/hIH/6wEv+10HRXtBoMrW3SJc7OIBmuM1jjqbT/WR/19rlugBm5x4mL1ZFY2PjoYKIhAIIJGzG4biSc/UIQ801NdKPaB42+ZcPwVPrVgRjuCL7khbzMFM+JzwgQA54kp6YSnE1cfGNIdpLVjIzyhJBlpChn6ZDya+L2mnB37J8yOO02+BQJ+ZxoL/A10VLYE4RAvurMWC/YPjPK+Bszl9eEdE2iQyzddWOlCkYfrdOC7zcjdpkcoDNXGfCddKXC77uI/L0kFYxzAEANEdEWclrwP5+f5AnZyr8hVp6XyR3Zg7S4t8iSAXrQIP1tI3h50qNj1OAluQCqM43HXSz199LzAtruJQpv094V0/oey7IuRrXq/fiTrkmFNyB/tWqeNp9vZO19R+xSI4g8= Pro Tip: You can add it automatically by running with --add. 保存這個secure值,在連接travispush生成的代碼到gh-pages分支時會使用這個secure,我們需要配置到. travis. yml文件裡面 . travis. yml文件: 将刚才生成的secure放入. travis. yml文件中, 完整文件: 123456789101112language: rubyrvm:- 2. 7. 0branches: only: - masterinstall:- bundle installscript: bundle exec rake deploy --quietenv: global:  secure: ${secure} 编译和psuh的整个过程都通过script: bundle exec rake deploy --quiet交由rake完成 rake实现编译和push: Rakefile: 在根目录下新建一个Rakefile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869############################################################################### Modified version of jekyllrb Rakefile# https://github. com/jekyll/jekyll/blob/master/Rakefile##############################################################################require 'rake'require 'date'require 'yaml'CONFIG = YAML. load(File. read('_config. yml'))USERNAME = CONFIG[ username ] || ENV['GIT_NAME']REPO = CONFIG[ repo ] ||  #{USERNAME}. github. io # Determine source and destination branch# User or organization: source -&gt; master# Project: master -&gt; gh-pages# Name of source branch for user/organization defaults to  source if REPO ==  #{USERNAME}. github. io  SOURCE_BRANCH = CONFIG['branch'] ||  source  DESTINATION_BRANCH =  master else SOURCE_BRANCH =  master  DESTINATION_BRANCH =  gh-pages enddef check_destination unless Dir. exist? CONFIG[ destination ]  sh  git clone https://#{ENV['GIT_NAME']}:#{ENV['GH_TOKEN']}@github. com/#{USERNAME}/#{REPO}. git #{CONFIG[ destination ]}  endendtask :deploy do  # Detect pull request  if ENV['TRAVIS_PULL_REQUEST']. to_s. to_i &gt; 0   puts 'Pull request detected. Not proceeding with deploy. '   exit  end  # Configure git if this is run in Travis CI  if ENV[ TRAVIS ]   sh  git config --global user. name '#{ENV['GIT_NAME']}'    sh  git config --global user. email '#{ENV['GIT_EMAIL']}'    sh  git config --global push. default simple   end  # Make sure destination folder exists as git repo  check_destination  sh  git checkout #{SOURCE_BRANCH}   # Generate the site  #sh  bundle exec jekyll build   puts CONFIG[ destination ]  Dir. chdir(CONFIG[ destination ]) { sh  git checkout #{DESTINATION_BRANCH}  }  sh  bundle exec jekyll build   # Commit and push to github  sha = `git log`. match(/[a-z0-9]{40}/)[0]  Dir. chdir(CONFIG[ destination ]) do   sh  git add --all .     sh  git commit -m 'Updating to #{USERNAME}/#{REPO}@#{sha}. '    sh  git push --quiet origin #{DESTINATION_BRANCH}    puts  Pushed updated branch #{DESTINATION_BRANCH} to GitHub Pages   endendGemfile: 添加rake到Gemfile中,这样子bundle install就会自动安装rake以及依赖. 没有Gemfile则新建一个 12gem  rake gem  github-pages ,  &gt;= 204 修改_config. yml: 最后需要把Rakefile,Gemfile以及. travisi. yml等添加添加到配置文件的exclude. 配置文件等不作为编译的内容 123456789101112exclude: - README. md - Rakefile - Gemfile - Gemfile. lock - changelog. md -  *. Rmd  - vendor - . travis. yml - LICENSE. txtdestination: . /build_site/新建一个repo变量,变量值为你的源码仓库的名字,在rake中push代码时会读取 1repo: ${your-blog}现在,在本地push代码到github以后,travis就会自动部署到你的github pages,你的github pages地址为 12https://${user}. github. io/${your-blog}完整源码服务器: 如果使用服务器部署,源码的模板如下 travis : https://github. com/yan-wyb/source/tree/master/web/blog/jekyll/travis-to-server nginx : https://github. com/yan-wyb/source/blob/master/web/nginx/nginx. conf github Pages: 如果部署在github pages,模板如下 travis : https://github. com/yan-wyb/source/tree/master/web/blog/jekyll/travis-to-github-pages note   gitlab操作与github相同     部署到github-pages的话,部署分支名字只能为gh-pages     凡是${ }的都要替换  issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 82,
    "url": "/2020/06/06/nginx.html",
    "title": "nginx",
    "body": "2020/06/06 - nginx安装配置以及使用 安装nginx源安装工具安装nginx: linux各大发行版都可以通过源安装工具直接安装nginx,这里以APT源为例. 1$ sudo apt install nginx通过发行版的软件管理包直接安装需要检查是否安装了ssl模块(只使用http可忽略这一步骤) 12345$ nginx -Vnginx version: nginx/1. 14. 0 (Ubuntu)built with OpenSSL 1. 1. 1 11 Sep 2018TLS SNI support enabledconfigure arguments: --with-cc-opt='-g -O2 -fdebug-prefix-map=/build/nginx-GkiujU/nginx-1. 14. 0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC' --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx. conf --http-log-path=/var/log/nginx/access. log --error-log-path=/var/log/nginx/error. log --lock-path=/var/lock/nginx. lock --pid-path=/run/nginx. pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module可以看到 –with-http_ssl_module. 源码安装: 从源码安装ngix,需要先解决以来问题,再从官网下载代码编译 下载源码: 进入 nginx官网 , 从右边栏目中找到Download, 点击进去下载Mainline版本或者Stable版本.  推荐使用stable版本,如果你对nginx足够熟悉或者想尝试新特性,可以安装mainline版本 123$ cd ${workspace}$ wget http://nginx. org/download/nginx-x. xx. x. tar. gz$ tar zxvf nginx-x. xx. x. tar. gz 安装需要的依赖: 需要的依赖都是非常基础的linux包,基本都可以通过发行版的源安装工具直接安装,以APT源为例. 12$ sudo apt update$ sudo apt install build-essential libtool libpcre3 libpcre3-dev zlib1g-dev openssl配置环境并编译: 1234567891011$ cd ${workspace}/nginx-x. xx. x/$ . /configure \    --prefix=/usr \    --sbin-path=/usr/sbin/nginx \    --conf-path=/etc/nginx/nginx. conf \    --error-log-path=/var/log/nginx/error. log \    --http-log-path=/var/log/nginx/access. log \    --pid-path=/var/run/nginx/nginx. pid \    --lock-path=/var/lock/nginx. lock \    --with-http_stub_status_module \    --with-http_ssl_module如果你需要编译额外的模块,就加在这个配置后面 下一步就是编译和安装 12$ make$ sudo make install执行完make install之后就安装完成了. 配置nginx配置文件写权限: 配置文件在 /etc/nginx/nginx. conf , 修改配置文件时需要切换到root用户, 这个文件所有组是root. root 123$ suroot# chmod +w /etc/nginx/nginx. conf修改完成以后记得回复配置文件权限 1root# chmod -w /etc/nginx/nginx. conf配置文件修改: 所有的修改都是在配置文件的http类里 12http {}修改nginx用户: 1#user nobody; --&gt; user root注释下级目录: 注释掉不需要用的下级配置文件目录 12include /etc/nginx/conf. d/*. conf; --&gt; # include /etc/nginx/conf. d/*. conf;include /etc/nginx/sites-enabled/*; --&gt; # include /etc/nginx/sites-enabled/*;http的server: 如果只使用http,不使用https: 12345678910server {        listen 80;        server_name xxxx. com www. xxxx. com;#        return 301 https://www. xxxx. com$request_uri;        location / {            root /path/to/html;            index index. html index. htm;        }}https的server: 如果使用https,除了配置server,还要配置ssl证书: 1234567891011121314151617181920212223server {        listen 80;        server_nane xxxx. com www. xxxx. com;        return 301 https://www. xxxx. com$request_uri;#        location / {#            root /home/yan/website/blog/bare/_site/;#            index index. html index. htm;#        }}server {        listen 443 ssl;        server_name xxxx. com www. xxxx. com;        ssl on;        ssl_certificate /path/to/fullchain. pem;        ssl_certificate_key /path/to/privkey. pem;        ssl_dhparam /etc/ssl/certs/dhparams. pem;        ssl_protocols SSLv3 TLSv1 TLSv1. 1 TLSv1. 2;        ssl_ciphers HIGH:!aNULL:!MD5;        location / {            root /path/to/html;            index index. html index. htm;        }}ssl证书: note : : ssl证书申请,请按照–&gt;ssl申请与配置 设置log文件路径: 12access_log /var/log/nginx/access. log;error_log /var/log/nginx/error. log;nginx服务修改完了以后,直接重启系统或者重启nginx服务就会生效 直接在网页输入127. 0. 0. 1 ,如果配置成功就能直接看到你的网页内容了 other完整的nginx文件位置: 完整的nginx配置文件在我的github上 : https://github. com/yan-wyb/source/blob/master/web/nginx/nginx. conf nginx -t: 使用nginx -t 可测试nginx配置文件是否存在语法错误 123root# nginx -tnginx: the configuration file /etc/nginx/nginx. conf syntax is oknginx: configuration file /etc/nginx/nginx. conf test is successful同时nginx -t可以显示出配置文件路径,这个可以在找不到配置文件路径时使用 log文件使用: 在nginx工作不正常时可以通过配置文件里的配置log文件路径 12access_log /var/log/nginx/access. log;error_log /var/log/nginx/error. log;查看服务启动时的log信息和error信息 issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 83,
    "url": "/2020/06/05/ruby.html",
    "title": "ruby",
    "body": "2020/06/05 - 通过RVM安装ruby,可以安装多个版本的ruby,兼容性也更好 安装rvm安装依赖: rvm依赖gnupg2,首先要保证GPG(GNU Privacy Guard)是最新的版本,才能通过公钥获取到正确的私钥 1$ sudo apt install gnupg2密钥签署RVM版本: 我们将要求RVM项目的密钥签署每个RVM版本. 拥有RVM项目的公钥允许我们验证我们将要下载的RVM版本的合法性,该版本使用匹配的私钥进行签名 1$ gpg2 --keyserver hkp://keys. gnupg. net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB获取rvm安装脚本: 现在通过curl下载最新的rvm安装脚本. 12$ cd ${workspace}$ \curl -sSL https://get. rvm. io -o rvm. sh安装rvm: 现在通过shell执行该脚本就会安装rvm 12$ cd ${workapace}$ cat rvm. sh | bash -s stable --rails这个过程需要等待比较长的时间,而且由于服务器在国外,没有’科学上网’的一般都会很慢,甚至需要中止安装过程,重新加载好在使用curl -sSL中断重新执行,之前下载的部分会保留,接着下载,而不是重头下载 安装rubyrvm安装完会默认安装最新的ruby版本. 此时可以选择你需要安装的ruby版本 source rvm: 安装完的rvm的环境会在下次开机时加载,可以通过source命令立即加载rvm 1$ source ~/. rvm/scripts/rvm查看ruby版本: 查看可安装的ruby版本 1$ rvm list known查看已安装的ruby版本 1$ rvm list安装和切换版本: 安装不同的ruby版本 1$ rvm install ruby_version /*`ruby_version`格式为`ruby-x. x. x或者x. x. x`*/切换你需要ruby版本 1$ rvm use ruby_version /*`ruby_version`格式为`ruby-x. x. x或者x. x. x`*/卸载和重装: uninstall和reinstall可用于下载和重装 12$ rvm uninstall ruby_version /*`ruby_version`格式为`ruby-x. x. x或者x. x. x`*/$ rvm reinstall ruby_version /*`ruby_version`格式为`ruby-x. x. x或者x. x. x`*/bundlerbundler是一个非常重要的ruby包,可以保证应用依赖的所有包以及依赖包的依赖都被安装 安装bundler: 1$ gem install bundler使用bundler: 在Gemfile里面声明依赖,然后在应用的目录运行 1$ bundle installbundler就会自动安装这些包和这些包的依赖包 ruby和bundler换源ruby的服务器在国外,访问是极其慢的,甚至根本访问不了,解决方法就是将源更换为国内的源 ruby 换源 1$ gem sources --add https://gems. ruby-china. com/ --remove https://rubygems. org/bundler 换源 1$ bundle config mirror. https://rubygems. org https://gems. ruby-china. com官方rvm官网: https://rvm. io ruby官网: https://www. ruby-lang. org bundler官网: https://bundler. io issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 84,
    "url": "/2020/06/05/add-user.html",
    "title": "add user",
    "body": "2020/06/05 - linux新增带超级权限的普通用户 切换root新增用户需要很多权限去设置一些东西,这里切换到root用户做处理 1$ su新建主目录新建主目录位置,一般新建在home/目录下,也有选择usr目录的 12root# mkdir /home/[USER] /*主目录设置在`/home/`下*/root# mkdir /usr/[USER]  /*主目录设置在`/usr/`下*/新增group和user新增用户组和组下的用户 12root# groupadd [group]root# useradd -d /home/[user] -g [group] -s /bin/bash [user]建议group和user使用同一个名字,如果你有新建多用户的需求可以分开设置不同的名字 增加sudo权限超级权限的配置文件为/etc/sudoers , 这个是全用户的只读文件,需要先添加写权限,改完以后恢复权限 12root# chmod +w /etc/sudoersroot# vim /etc/增加一行在root下面 12# User privilege specificationroot	ALL=(ALL:ALL) ALL修改为 123# User privilege specificationroot	ALL=(ALL:ALL) ALL[user] ALL=(ALL:ALL) ALL修改完以后去除写权限 1root# chmod -w /etc/sudoers修改主目录权限和所属修改主目录的所属用户组 12root# chown -R [group]. [user] /home/[user] /*主目录设置在`/home/`下*/root# chown -R [group]. [user] /usr/[user] /*主目录设置在`/usr/`下*/修改主目录权限 12root# chmod -R 755 /home/[user] /*主目录设置在`/home/`下*/root# chmod -R 755 /usr/[user] /*主目录设置在`/usr/`下*/设置user密码1root# passwd [user]到此,所有的设置完成. 通过su [user]命令可以切换到你的新用户 issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 85,
    "url": "/2020/05/30/ssh.html",
    "title": "ssh",
    "body": "2020/05/30 - ssh是linux远程操作和管理服务的重要工具 安装ssh使用各发行版的包安装工作直接安装即可,这里以ubuntu为例 1$ sudo apt install sshssh常用命令ssh连接远程host: 使用ssh登录服务器或者局域网下的其他主机是很常用的一种方式,特别在嵌入式开发里. 1$ ssh host-usename@host-ipaddress比如: 1$ ssh root@192. 168. 1. 250退出远程连接: 使用exit命令就能退出远程连接. 1$ exitssh拷贝文件: scp是最常用的用来和远程进行数据交互的工具,-r参数可直接交互整个文件夹 123$ scp [[user@]host1:]file1 . . . [[user@]host2:]file2$ scp -r [[user@]host1:]file1 . . . [[user@]host2:]file2host1是拷贝位置,host2是目标位置. 则拷贝文件到远程主机,host1是你的主机,host2是远程主机. 从远程主机拷贝文件到本地反过来即可. 例如: 12$ scp ~/ssh. txt root@10. 72. 1. 16:~ #从本地copy到远程主机$ scp root@10. 72. 1. 16:~/ssh. txt ~ #从远程主机copy到本地ssh key生成ssh key: linux下可直接在终端通过ssh的命令生成ssh key 1$ ssh-keygen -t rsa -C  you@email. com 都选择默认选项就可以生成相应的key 查看生成的key: 1$ cat ~/. ssh/id_rsa. pub添加到ssh-agent: ssh-agent 就是key管理器，主要用于管理公钥验证使用的私钥。 12$ eval  $(ssh-agent -s) $ ssh-add ~/. ssh/id_rsaGit使用ssh以github为例，gitlab和gitee是同样的。 添加key到github: 打开github页面，打开个人设置 在左边的栏目找到SSH Key 然后在主界面的上面就有一个新增ssh key的按键 将生成的SSH Key添加到key里，titile可以随意设置 Add SSH Key以后就添加完成了 测试Git的ssh配置是否成功: 12$ ssh -T git@github. comHi yan-wyb! You've successfully authenticated, but GitHub does not provide shell access. 看到这个说名配置已经成功了。之后使用ssh来clone和push代码，就不再需要输入密码了。 1$ git@github. com:khadas/khadas_docs. git注意: 以git@开头的才是使用ssh方式clone的,以http://开头的就是使用https://方式 ssh免密登录客户端: 指使用id_rsa进行ssh登录的端,常常为你正在操作远程登录的PC端,或者部署工具端,如travis 服务端: 值接受id_rsa. pub并保存进authorized_keys的端,常常是服务器如阿里云或者github. 注意: 免密登录对权限极其敏感 客户端操作: 首先生成一对秘钥,生成方法可以参考上面的ssh key,为密钥对设置权限 12$ chmod 600 ~/. ssh/id_rsa$ chmod 600 ~/. ssh/id_rsa. pub将公钥添加到服务端的授权文件里 1$ ssh-copy-id -i ~/. ssh/id_rsa. pub user@xx. x. xx. x /*1. 公钥可以使用自定义的;2. user是服务端用户名;3. xx. x. xx. x是服务器地址,也可以使用域名*/输入远程登录的密码,就添加成功了 服务端操作: 服务端只需要设置权限就可以 1$ chmod 600 ~/. ssh/authorized_keys测试: 客户端使用ssh登录 1$ ssh user@xx. x. xx. x直接登录即为设置成功,需要输入密码应检查权限问题. 主目录权限必须小于等于755 ssh端口映射通过SSH可以将远程端口映射回本地，方便在搭建网站或者Blog时，本地访问，查看效果。 示例，将远程的8888端口，映射到本地的8888端口。 1$ ssh -L8888:localhost:8888 username@192. 168. xx. xxx"
    }, {
    "id": 86,
    "url": "/2020/05/30/git.html",
    "title": "Git",
    "body": "2020/05/30 - Git个人常用的一些配置 设置git用户信息切换到仓库的目录,设置用户邮箱和名字，才能提交代码。 123$ cd /path/to/repository$ git config user. name [username]$ git config user. email [email]如果希望这个设置在全局都生效可以加上--global参数 12$ git config --global user. name [username]$ git config --global user. email [email]设置默认的commit编辑器默认的编辑器是nano,可以修改为vim或者其他你喜欢的编辑器 1$ git config --global core. editor vim. ignore-update在根目录下添加. ignore-update文件,指定git更新的文件。此文件为空，则git fetch不会更新任何内容。 1$ touch . ignore-updatebranch操作切换远程分支 12$ git checkout remotes/origin/[branch]$ git checkout -b [branch]新建分支在当前分支基础上新建分支 123$ git branch [branch]$ git checkout [branch]$ git push origin [branch]issues如果有疑惑或错误,请提issues –&gt; Issues "
    }, {
    "id": 87,
    "url": "/2020/05/29/vim-config.html",
    "title": "VIM",
    "body": "2020/05/29 - VIM编辑器配置 安装VIM直接使用系统的包管理器或者软件中心安装。以ubuntu为例 1$ sudo apt install vim或者从官方的git上面clone,然后编译。 123$ git clone https://github. com/vim/vim. git$ cd vim/src$ makeVIM配置文件默认安装的VIM是没有配置文件。在home目录创建一个，文件名. vimrc。每次VIM启动都会默认在home目录下加载这个配置文件. 1$ touch ~/. vimrc简单的配置一下这个文件，如打开行号，tab键的功能等. 1234567891011121314151617181920syntax onset cindentset hlsearchset nuset cursorlineset ts=4set expandtab%retab!set sw=4 set tabstop=4set fencs=utf-8,GB18030set background=darkif has( autocmd )au BufReadPost * if line( '\  ) &gt; 1 &amp;&amp; line( '\  ) &lt;= line( $ ) | exe  normal! g'\   | endifendifissues如果有疑惑或错误,请提issues –&gt; Issues "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});